---
title: "Альфредо Риаль - Создание анонимных учётных записей с помощью механизма порогового оформления"
date: "2023-06-24"
categories:
  - "Стенограмма"
tags:
  - "MoneroKon 2023"
lead: "Monero Konferenco 2023 #MoneroKon2023 Прага - День 2"
pager: true
toc: false
sidebar: "right"
---

{{< youtube id="mNJd6Ebrty8" autoplay="false" >}}

---

_**Альфредо:**_ Большое спасибо за вступление. Я очень рад находиться здесь. Спасибо всем вам за то, что пришли на эту презентацию в это воскресное утро. Мне очень приятно.

Итак, действительно, в NYM мы обеспечиваем приватность на сетевом уровне с помощью смешанной сети. Но в дополнение к этому мы также обеспечиваем приватность на уровне приложений, используя анонимные учётные данные и анонимную электронную валюту. И в рамках этого выступления я собираюсь сосредоточиться именно на этой части, на обеспечении приватности на уровне приложений.

Прежде всего, я кратко опишу, что такое анонимные учётные данные. Уверен, многие из вас уже знакомы с этой темой, но в любом случае я сделаю краткое введение.

Итак, можно сказать, что учётная запись является цифровым аналогом физической учётной записи, такой как паспорт, удостоверение личности, водительские права и так далее. По сути, учётная запись - это нечто, подтверждающее, что вы обладаете определёнными атрибутами: национальностью, именем, датой рождения и тому подобным. Таким образом, цифровая учётная запись - это, по сути, подпись. Кто-то удостоверяет, что вы обладаете всеми этими атрибутами, и предоставляет вам подпись, подтверждающую их.

Если для реализации анонимных учётных записей мы будем использовать только подписи, то получим схему, не обеспечивающую приватности. Причина проста: когда вы хотите продемонстрировать свои полномочия, вам приходится раскрывать все свои атрибуты. Так, например, при наличии какого-либо верификатора учётных записей, например поставщика интернет-услуг, которому необходимо проверить, старше вы 16 лет или нет, если вы предъявите свою подпись, то для проверки вашего возраста верификатору придётся проверить, увидеть все ваши атрибуты. Вот для чего необходимы анонимные учётные записи. Наша цель состоит в том, чтобы, при демонстрации учётной записи верификатору в нашем случае он узнавал только то, что ваш возраст старше 16 лет, и не получал никакой дополнительной информации, даже самой учётной записи - только тот факт, что вам больше  16 лет.

Итак, чтобы создать схему анонимных учётных записей,  требуется реализовать идею использования цифровых подписей с помощью двух протоколов: указанного здесь протокола демонстрации и протокола слепого оформления. И сначала поговорим о протоколе демонстрации.

Как и в случае с уже описанным мной примером, если бы мы просто отправили учётную запись, подпись, то нам пришлось бы раскрыть все наши атрибуты, и верификатор узнал бы их, верно? Поэтому в протоколе демонстрации мы используем, по сути, доказательство с нулевым разглашением. Мы делаем это для того, чтобы доказать обладание учётной записью. Итак, при использовании доказательства обладания подписью с нулевым разглашением, мы берём нашу учётную запись, создаём токен представления, состоящий из доказательства с нулевым разглашением и доказательства того, что возраст или дата рождения, связанные с нашей учётной записью, указывают на то, что вы старше 16 лет. При этом не раскрывается никакой дополнительной информации о других атрибутах или даже сам возраст или дата рождения. И с помощью такого протокола демонстрации мы можем обеспечить собственную приватность при проверке верификатором учётных записей.

Кроме того, у нас есть протокол оформления. То есть, тот, кто оформляет учётные записи должен узнать все ваши атрибуты, чтобы проверить их, так? Например, он должен подтвердить дату вашего рождения и тому подобное. Но есть случаи, когда в этом нет необходимости. Например, представьте, что у вас уже есть удостоверение личности, в котором подтверждены все ваши атрибуты. А затем, чтобы получить уже другое удостоверение со всеми этими атрибутами, вам нужен другой верификатор. Тогда вы можете сделать следующее: воспользовавшись доказательством с нулевым разглашением, подтвердить, что у вас уже есть другое удостоверение, и тогда лицу, оформляющему новое удостоверение, не нужно будет заново изучать все ваши атрибуты. Можно будет просто подписать атрибуты, которые уже были подписаны ранее, и выдать вам новую учётную запись. Именно так мы поступаем в NYM - нам не нужно знать ваши атрибуты. Мы доверяем тому, что у вас уже есть действительный паспорт, например. То есть мы не доверяем, мы проверяем, обладаете ли вы им - вы представляете свои атрибуты в доказательстве с нулевым разглашением, а затем мы их повторно подтверждаем и выдаём новую учётную запись.

Итак, вероятно, вы уже поняли, каковы основные свойства безопасности анонимных учётных записей. В случае использования протокола оформления происходит слепое оформление, что означает, что некоторые атрибуты вы можете подписать у стороны, оформляющей учётную запись, не раскрывая их. Это гибкий подход. Такой стороне может быть необходимо знать одни атрибуты, и совершенно нет необходимости в знании других. И ваши атрибуты также могут быть подтверждены доказательством с нулевым разглашением. Например, так можно доказать, что они уже были подписаны ранее.

Протокол демонстрации также обеспечивает невозможность подделки. То есть, злоумышленник не сможет создать токен представления для определённой политики контроля доступа, если у него нет учётной записи с атрибутами, соответствующей политике контроля доступа. Также протоколом обеспечивается свойство несвязываемости, необходимое для поддержания приватности и анонимности. По сути, несвязываемость означает, что если вы предъявляете свою учётную запись, создав два токена представления, чтобы предъявить их двум разным верификаторам или даже одному и тому же верификатору в разное время, то эти токены презентации будут несвязанными. И даже если верификатор вступит в сговор с оформителем учётной записи, то есть, даже если оформитель учётной записи и верификатор - одно и то же лицо, они не смогут связать выдачу учётной записи с токеном представления. И эти свойства обеспечивают приватность, необходимую пользователям на уровне приложений.

Большинство схем анонимных учётных записей появилось в течение последних двадцати лет. Существуют самые различные схемы, но до недавнего времени все они предусматривали наличие одной доверенной стороны, оформляющей учётную запись и надлежащим образом подтверждающей атрибуты. Идея заключается в том, что пользователь обращается к стороне, оформляющей учётную запись, которая удостоверяет, что пользователь имеет такую-то дату рождения, такую-то национальность и так далее, а затем выдаёт учётную запись. А это предполагает наличие определённого доверия, и если оформляющая запись сторона будет коррумпирована, она сможет оформлять фальшивые учётные записи кому угодно, верно?

Мы в NYM делаем всё, чтобы избежать подобного сценария. И недавно было предложено несколько схем анонимных учётных записей, использующих механизм «порогового оформления». Пороговое оформление означает, что вместо одной стороны, оформляющей учётную запись, привлекается N таких сторон. И идея заключается в том, что пользователю необходимо взаимодействовать с ними, чтобы получить часть учётной записи от всех этих сторон и в итоге получить действительную учётную запись. То есть, пользователь должен получить часть учёной записи, по крайней мере, от порогового количества сторон t, меньшего или равного N, а затем, когда это будет сделано, с помощью алгоритма, и пользователь получит действительную учётную запись, которую можно будет проверить с помощью открытого ключа системы.

Далее, как я уже говорил, в основе учётных записей лежит схема подписи. И в данном случае в NYM мы используем схему подписи, которая строится по принципу подписи Пойнтчевала-Сандерса. Я вкратце опишу эту схему. Я не стану вдаваться в детали, но для понимания наиболее важных аспектов, мне всё же придётся немного рассказать, как работают подписи Пойнтчевала-Сандерса.

Существует алгоритм, задающий спецификации билинейной карты, то есть, создающий описание билинейных групп и двух генераторов. Затем происходит генерация открытого и секретного ключей. В данном случае секретный ключ состоит из двух элементов в экспоненте. А открытый ключ, как и следовало ожидать, - это g в степени x и g в степени y.

Ещё один более важный момент - вычисление подписи. Как видите, наша подпись довольно проста. Если мы хотим подписать сообщение m, мы берём генератор случайных чисел и производим соответствующие вычисления. Сейчас я описываю версию схемы, предусматривающей наличие лишь одного сообщения. На практике мы используем схему, позволяющую подписывать сразу несколько сообщений. Но в данном случае для простоты показана схема с одним сообщением. Что касается верификации, то, по сути, проверяется, действительно ли h является генератором, а также правильность его вычисления.

Важно, чтобы этот генератор h был случайным и уникальным для каждого подписываемого сообщения. Таким образом, для того чтобы схему нельзя было подделать, мы изначально допускаем, что она генератор создаётся специально. Был проведён ряд исследований такого допуска, и в рамках общей групповой модели было доказано, что он работает. То есть исследования проводились целенаправленно, и результаты показали, что всё действительно работает, как надо.

Итак, сейчас мы используем схему учётных записей на основе подписей Пойнтчевала-Сандерса. Изначально, в 2019 году, был предложен механизм порогового оформления и схема анонимной учётной записи под названием Coconut. А используемая нами схема уже основана на Coconut.

Наша схема построения учётной записи включает в себя четыре этапа. Мы используем алгоритм генерации ключа, но теперь сторона, использующая механизм порогового оформления, будет получать свой собственный набор ключей. И это делается с помощью данного алгоритма. Затем мы задействуем протокол слепого оформления, как это уже было показано на первом слайде. Кроме того, мы используем алгоритм агрегирования, благодаря которому, когда пользователь получит все части учётной записи, он сможет создать учётную запись, которую можно будет проверить с помощью открытого ключа системы. И, наконец, протокол демонстрации.

В Coconut был предложен механизм порогового оформления анонимной учётной записи, которая имела, ну я не сказал бы проблемы, которая имела два недочёта. Прежде всего, приватность не обеспечивалась безусловно. Она обеспечивалась с помощью вычислительного допуска. Поэтому мы внесли некоторые изменения в Coconut, чтобы и слепое оформление, и приватность в рамках протокола демонстрации, синхронно обеспечивались без каких-либо допусков, на основе теории информации или безусловно. Кроме того, сделав это, мы смогли повысить эффективность схемы. Это описано в нашей работе, где также приводится анализ безопасности схемы создания учётной записи.

Итак, во-первых, как я уже сказал, мы заменяем алгоритм генерации ключа другим алгоритмом, который вычисляет часть ключа для каждого пользователя. По сути, мы используем схему разделения секрета Шамира. Уверен, большинство из вас знакомы с ней. В случае со схемой, в которой подписывается только одно сообщение, у нас есть два случайных полинома, которые мы затем оцениваем и вычисляем каждую часть ключа. И наконец, мы, как обычно, вычисляем части открытого ключа. Но только здесь в открытый ключ добавляется ещё один элемент - в группу g, а также в группу g тильда. И делается это, как я уже говорил, для повышения уровня приватности протокола слепого оформления. Позже я продемонстрирую, как этот элемент используется для обеспечения приватности и безусловного слепого оформления.

И теперь, если мы используем этот алгоритм, то нам понадобится доверенная сторона, которая будет его выполнять, потому что доверенной стороне, реализующей алгоритм, будут известны все части секретных ключей всех сторон, оформляющих учётную запись. Поэтому вместо этого мы используем протокол распределённой генерации ключей, и реализованный нами протокол основан на протоколе неинтерактивной распределённой генерации ключей и их повторного совместного использования Джеймса Грота, в который мы внесли несколько изменений, но, по сути, протокол остался тем же.

Итак, как работает протокол слепого оформления? Идея заключается в том, что в рамках данного протокола у нас есть пользователь, который вводит сообщение, и ему нужно трижды вступить во взаимодействие со сторонами, оформляющими учётную запись, чтобы получить части этой учётной записи. При каждом таком взаимодействий с оформителем учётной записи он вводит свою собственную часть ключа. А на выходе пользователь получает часть учётной записи, которая, по сути, является подписью сообщения, подписью Пойнтчевала-Сандерса, использующей часть, которой обладает одна из сторон, оформляющих учётную запись.

Основная сложность создания, разработки протокола слепого оформления заключается в том, что, как было показано на предыдущем слайде, существует генератор h, который должен быть уникальным, случайным, и все стороны, вовлечённые в оформление учётной записи, должны договориться об общем h, не связываясь при этом между собой. В связи с этим генератор h подбирается пользователем следующим образом. Сначала пользователь вычисляет обязательство Педерсена для сообщения, а затем вычисляет h как хэш этого обязательства. Теперь, если мы смоделируем хэш-функцию h как случайный оракул, мы сможем доказать, что генератор h является случайным. Также свойство связываемости обязательств Педерсена гарантирует, что каждый генератор h будет разным для каждого подписанного сообщения. А затем, в рамках процедуры слепого оформления, пользователь вычисляет для сообщения другое обязательство, используя h в качестве генератора в обязательстве Педерсена. Наконец, существует сериализованное доказательство, подтверждающее, что всё это было оформлено верно.

После того как сторона, оформляющая учётную запись, получит этот запрос, она выдаст ответ, для вычисления которого используется секретный ключ, принадлежащий стороне, оформляющей запись. Пользователь получает этот ответ и использует открытие этого обязательства, чтобы разблокировать ответ и получить часть, переданную оформляющей стороной, которая такая же, как и здесь, верно? И здесь, на этапе разблокировки, мы использовали новый элемент открытого ключа - вот зачем он был нужен. А раньше, в предыдущей версии Coconut, использовалось шифрование по схеме Эль-Гамаля, и поэтому при доказательстве приватности использовался допуск вычислительной сложности. Мы заменили схему Эль-Гамаля на обязательство Педерсена, и благодаря этому можем разблокировать ответ с помощью дополнительного элемента открытого ключа. Как результат повышается общая эффективность, равно как и приватность, которая обеспечивается безусловно.

И после того, как пользователь получит учётную запись, по крайней мере, её части, он сможет вычислить полную учётную запись, верифицируемую с помощью открытого ключа системы с использованием интерполяции Лагранжа. Итак, у нас есть части записи, и с помощью интерполяции Лагранжа мы можем получить полную учётную запись, которую можно проверить с помощью секретного ключа системы, то есть, путём проверки полиномов на равенство нулю. Поэтому интерполяция производится по нулевому значению.

И теперь немного о протоколе демонстрации. Я не стану описывать его во всех подробностях, просто скажу, что в Coconut уже существовал такой протокол, и он был улучшен. Итак, в оригинальной работе, посвящённой подписям Пойнтчевала-Сандерса, уже говорилось о протоколе демонстрации, который был немного неэффективным. В Coconut уже существовал протокол демонстрации, который был улучшен, но приватность при этом обеспечивалась на основе допуска вычислительной сложности. И мы модифицировали этот протокол из Coconut так, что теперь свойство несвязываемости обеспечивается безусловно, равно как и свойство сериализации. Также повышается эффективность, хотя, хочу отметить, это небольшое улучшение. Все подробности содержатся в работе, которую я уже упоминал.

До сих пор я говорил только о пороговом оформлении и об анонимных учётных записях, которые мы могли бы использовать для обеспечения приватности при управлении доступом. Но мы также хотим реализовать и анонимные платежи, правильно? И для этого мы так же можем использовать анонимные учётные записи, модифицировать их, добавив две дополнительные возможности и получить анонимную электронную валюту, верно?

Идея заключается в создании протокола с пороговым оформлением. У нас есть протокол, в котором есть фаза оформления. И поскольку речь идёт об электронных деньгах, я назвал это ваучером учётной записи. Но, по сути, это снова подпись, позволяющая подписывать сумму выводимых средств. Итак, на этапе оформления пользователь выводит ваучер и с помощью алгоритма агрегации получает сам ваучер, а затем вычисляет платёж, что, по сути, является доказательством владения подписью, что он обладает этим ваучером. И наконец, поставщик услуг получает платёж, проверяет его и передаёт дальше для получения своих денег.

Но здесь упущен тот факт, что, если бы пользователь мог потратить ваучер столько раз, сколько захочет, он мог бы, по сути, использовать его вечно. Поэтому необходим какой-то механизм, позволяющий избежать двойной траты. Это одна из вещей, требующих реализации для превращения механизма порогового оформления, анонимные учётных записей, в анонимные электронные деньги.

Также существует и проблема выплаты точной суммы. Проблема состоит в том, что в случае с анонимными электронными деньгами, если мы хотим обменять их на криптовалюту, не обеспечивающую приватность пользователя, или даже на фиатную валюту, то этот этап не будет анонимным, верно? Потому что нам нужно конвертировать электронные деньги в валюту, не являющуюся анонимной. Поэтому, уже когда мы вносим наши средства, мы теряем анонимность. И по этой причине, когда пользователь платит поставщику услуг, поставщик услуг не может дать сдачу, поскольку если он сделает это, пользователю придётся положить её на свой счёт, и он утратит анонимность. Поэтому пользователь должен иметь возможность заплатить точную сумму. И это актуально только в том случае, если мы хотим конвертировать электронные деньги в фиатную валюту, в криптовалюту, не обеспечивающую приватность. Но если мы захотим конвертировать её обратно в электронные деньги, то это можно сделать анонимно. Так что, по сути, мы должны решить две проблемы - проблему выявления двойной траты и проблему выплаты точной суммы.

Чтобы решить проблему обнаружения двойной траты, мы к каждому ваучеру добавляем серийный номер. Таким образом, ваучер, помимо подписи, подтверждающей  сумму, также подписывается серийным номером. Серийный номер уникален и выбирается пользователем. И когда происходит вычисление платежа, пользователь показывает только серийный номер. Поставщик услуг проверяет платёж, а затем, когда он положит средства на счёт, проверяется, является ли такой серийный номер уникальным и не использовался ли он при совершении предыдущих платежей. Для этого можно использовать реестр, содержащий серийные номера всех предыдущих платежей. И для реализации такого специального реестра мы можем интегрировать его в блокчейн, который будет конвертировать наш криптовалютный токен в электронные деньги, а затем обратно электронные деньги в нашу криптовалюту. Таким образом, мы можем использовать тот же блокчейн для хранения всех реестров.

И наконец, чтобы решить проблему внесения точной суммы, мы используем обобщённый протокол оформления, в котором, например, если вы хотите заплатить 30, а у вас есть токен номиналом 50, то вы можете разделить его на токены номиналом 30 и 20, передав токен у оформителю, который выдаст вам токены нужного номинала. Но при этом он не будет знать ничего ни о потраченных, ни о полученных суммах. Поэтому, по сути, нам требуется без разглашения какой-либо информации доказать, что количество токенов, которые были переданы оформляющей стороне, равно количеству токенов, полученных от неё.

И это последний слайд. Итак, я говорил об анонимной электронной валюте, используемой онлайн, что, по сути, означает, что поставщик услуг, чтобы проверить действительность платежа, прежде чем принять его, должен связаться с компетентной стороной, чтобы проверить отсутствие двойной траты онлайн. Но есть и электронная валюта. которую можно использовать офлайн, и она позволяет поставщику услуг принимать платежи без обращения к такой третьей стороне. Для этого необходимо включить функцию идентификации двойных расходов. То есть в платеже ставятся теги двойной траты, и если пользователь совершает двойную трату, власти компетентная сторона сможет получить данные о его личности.

Таким образом, мы проработали применение механизма порогового оформления в рамках схем анонимных платежей, совершаемых офлайн. И в следующем месяце я собираюсь представить нашу работу на PETS. То есть, уже есть электронная версия нашей работы, и она уже в следующем месяце она будет представлена на PETS.

Спасибо всем за внимание.

---
title: "Марк Симкин - OCash: полностью анонимные платежи между лёгкими клиентами блокчейна"
date: "2024-06-07"
categories:
  - "Стенограмма"
tags:
  - "MoneroKon 2024"
lead: "Monero Konferenco 2024 #MoneroKon2024 Прага"
pager: true
toc: false
sidebar: "right"
---

{{< youtube id="H0vYR8yEpbw" autoplay="false" >}}

---

_**Аннотация выступления**_
_Мы занимаемся изучением создаваемых на базе блокчейна доказуемо анонимных платёжных систем, осуществляющих взаимодействие между блокчейном и лёгкими клиентами. Такое взаимодействие осуществляется через полные узлы, которые видят всю информацию, которую считывают и пишут лёгкие клиенты. Цель нашей работы состоит в обеспечении лёгких клиентов возможностью производить анонимные платежи, поддерживая при этом приватность даже относительно полных узлов, через которые они взаимодействуют с блокчейном.

Мы формализуем проблему в виде модели универсальной компонуемости и предлагаем доказуемо безопасное решение. В сравнении с уже существующими работами, мы первые, кто одновременно предлагает сильные гарантии анонимности, способ реализации доказуемой безопасности и анонимности при работе с полными узлами. Попутно нами было сделано ещё несколько вещей, которые сами по себе могут представлять определённый интерес.

Нами были определены и реализованы эффективные сжимаемые маяки случайности, с регулярными временными интервалами выдающие непрогнозируемые значения и позволяющие хранить все опубликованные значения в коротком журнале. Нами также были определены и построены дружественные к монетам анонимные схемы шифрования и было продемонстрировано, как они могут использоваться в анонимных платёжных системах. Нами была определена и построена единожды считываемая карта с сильным свойством забывчивости, которую можно рассматривать в качестве особой структуры данных, соответствующей понятию более сильной, чем принято подразумевать, забывчивости. Нами предлагается новый подход, применимый к лёгким клиентам и обеспечивающий защиту от атак двойной траты в анонимных криптовалютах.

_**Стенограмма выступления:**_

_**Марк:**_ Рад приветствовать вас на этом выступлении. Я представляю OCash - такое вот очередное бесхитростное название. Меня зовут Марк. Это совместная работа. Я работаю в Ethereum Foundation, где занимаюсь исследованиями в составе команды криптографов. И это совместная работа, в которой также приняли участие два других исследователя из Орхусского университета в Дании, Адам Блетчли Хансен и Джеспер Бут Нильсен.

И в качестве отказа ответственности я должен сразу оговориться: в данной работе рассматривается очень сложная проблема и предлагается несколько нетривиальное решение или частичное решение. Если вам покажется, что в выступление не достаточно подробно, то это исключительно из-за того, что оно будет длиться всего 20 минут.

Итак, коротко о том, что такое блокчейн. Опять же, это объяснение на очень-очень высоком уровне. Допустим, есть некий блокчейн, представляющий собой огромный объём данных, и есть некий клиент, который позволяет отправлять и получать деньги посредством этого блокчейна. А поскольку так поступает множество людей, объём данных только увеличивается. Для отслеживания всего реестра приходится отслеживать сотни гигабайт данных. И если вы, скажем, являетесь обычным пользователем и не собираетесь поддерживать полный узел, но при этом хотите использовать возможности, предлагаемые блокчейном, то, вероятнее всего, вы не захотите для этого отслеживать сотни гигабайт данных.

И есть ряд решений этой проблемы. Одним из них являются лёгкие клиенты. Существуют разные варианты, но суть их сводится к тому, что вместо хранения всего объёма данных, необходимых для отслеживания всего происходящего в блокчейне, клиент обращается к полному узлу. Полный узел предоставляет всё необходимое, и взаимодействие с блокчейном происходит через него.

Таким образом, это решение предполагает наличие другой проблемы, к которой мы ещё вернёмся, - полному узлу видно всё то, что делает клиент, поскольку взаимодействие происходит через него. То есть, если клиент ориентирован на обеспечение некоторой приватности, он теряет её ри работе с полным узлом.

Поэтому в данном случае отдельного упоминания стоит возможная реализация анонимных платежей - всё-таки это MoneroKon. По умолчанию в классических блокчейнах или криптовалютах при публикации транзакций все видят всё то, что происходит. Но, возможно, вы не хотите, чтобы так происходило. Возможно, вы хотите обеспечить некоторую приватность своих транзакций. Поэтому на очень высоком уровне всё сводится к тому, что при переводе средств кому-либо, наблюдая за блокчейном, за тем, что я делаю, не должны видеть, кому я перевёл средства. И для этого существуют разные решения. Есть Zcash, есть Monero, есть другие. И все они обеспечивают очень разные гарантии анонимности.

Итак, у нас есть два пожелания или цели. Мы хотели бы иметь поддержку лёгких клиентов и возможность проведения анонимных платежей. В идеале было бы неплохо иметь и то, и другое. Именно этому и посвящено моё выступление.

Опять же, на очень высоком уровне, проблема заключается в том, что когда мы говорим о том, что нам необходима анонимность, мы имеем в виду не только анонимность в отношении какого-то внешнего злоумышленника, но даже в отношении полного узла, через который мы взаимодействуем с блокчейном. То есть, мы хотим иметь анонимность в полном смысле этого слова.

И тут возникает естественный вопрос: с учётом уже существующих подходов, используемых анонимными платёжными системами, можно ли создать лёгкие клиенты под них. И опять же, на очень высоком уровне, проблема заключается в том, что если взять, к примеру, Zcash - там используется накопительный подход. То есть, если вы захотите потратить монету - а при совершении транзакций, как правило, тратятся монеты, - и если вы захотите потратить такую монету, вам придётся вычислить своего рода доказательство. Но вычисление этого доказательства требует вычисления его для полного состояния. Однако лёгкий клиент едва ли станет это делать. Но кто-то всё-таки должен это сделать, и поэтому вы обращаетесь за этим к полному узлу. И тогда вы сталкиваетесь с проблемой: полный узел знает, что вы хотите сделать. И если вы хотите избежать этого, вы можете использовать такие механизмы, как поиск приватной информации. Это потребует огромного объёма работы со стороны полного узла, так что это не самое практичное решение проблемы.

И существует другой подход, основанный на использовании кольцевой подписи, который применяется, например, в Monero. И несмотря на то, что Monero, безусловно, обеспечивает нетривиальный уровень приватности, в последнее время появилось множество работ, в которых анонимность, обеспечиваемая Monero, изучалась с точки зрения графов. И не всегда ясно, какой объём анонимности вы получаете. То есть, очевидно, что вы получаете некоторую степень анонимности, но какую именно - вопрос открытый. Так что, будем честными, на данный момент вопрос изучен не достаточно хорошо.

Так в чём же состоит цель или в чём заключалась цель этой работы? А она заключалась в том, чтобы сделать шаг назад и определиться: вот у нас есть две задачи - нам бы хотелось иметь лёгких клиенты и возможность проведения анонимных платежей. Можно ли я создать криптовалюту или схематично построить криптовалюту, которая бы поддерживала обе эти вещи: обеспечивала бы поддержку лёгких клиентов, а самый высокий уровень анонимности из возможных?

И это именно то, что делает OCash. Дело пока не дошло до практической реализации. Это очень большая работа с кучей разных аспектов. И в своём выступлении я попытаюсь объяснить, как всё это работает. Но помимо разъяснений, я также хочу рассказать о нескольких вещах, которые были созданы нами попутно. Ведь, возможно, вам не понравится решение в целом, но отдельные вещи могут вас заинтересовать.

Итак, как я уже сказал, OCash, по сути, обеспечивает полную анонимность в том смысле, что когда я совершаю платёж, вы понятия не имеете, кому я заплатил. И точно так же, когда человек получает платёж, никто не может сказать, что за платёж был получен. Даже тот, кто совершил платёж, не сможет этого увидеть. И всё это работает с поддержкой лёгких клиентов. И, забегая вперёд, скажу, что кому-то может показаться спорным то, что наш консенсус основан на концепции комитетов. То есть, наш подход будет работать с блокчейнами, где консенсус обеспечивается путём объединения узлов в комитеты, совершающие определённые действия. Но если вы против такого типа консенсуса, то этот подход не для вас.

Итак, есть несколько инструментов, созданных нами попутно. Не буду вдаваться в подробности, но полагаю, что на очень высоком уровне вы догадаетесь, почему они могут быть полезны.

Прежде всего, на протяжении всего времени существования блокчейна должен использоваться маяк случайности. Этот случайности будет выдавать случайные значения, которые помогут в работе. Если вы используете лёгкий клиент, вы хотите, чтобы он как можно меньше взаимодействовал с блокчейном. Возможно, вы даже не захотите, чтобы он считывал все случайные значения, выданные маяком. Возможно, их просто будет слишком много. И нами был предложен маяк, генерирующий небольшие значения. При этом каждое новое значение будет выглядеть случайным, непредсказуемым, то есть будет соответствовать идее маяка случайности. Но у такого значения будет одна приятная особенность: при наличии последнего значения маяка вы сможете заново вычислить все предыдущие случайные значения. То есть, теперь, вместо того, чтобы хранить все значения, вы храните краткий журнал. Таким образом, лёгкий клиент, если ему понадобится предыдущее значение, просто прочитает соответствующее значение и на его основе вычислит то, которое ему нужно. Это первое.

Ещё одна проблема, с которой вы можете столкнуться при попытке объединить лёгкие клиенты и анонимные платежи, - предотвращение двойных расходов. Допустим, я - лёгкий клиент, и я получил платёж. Теперь мне нужно как-то проверить, что это не было попыткой двойной траты. И мы демонстрируем, что это можно сделать так, что получателю платежа в принципе е придётся заглядывать в блокчейн. Ему просто нужно отслеживать платежи, которые он получает от конкретного плательщика.

Наконец, мы предлагаем, так называемое дружественное к монетам анонимное шифрование. Когда монеты попадают в реестр, - сейчас я объясняю, как это работает, на высоком уровне, - это будут зашифрованные значения. А затем, по мере роста блокчейна, они будут перемещаться случайным образом. И тогда вам придётся доказывать, что шифротекст построен правильно, что он содержит значение, соответствующее принимаемому платежу, и так далее. И если делать это каким-то простым способом, то обычно, чтобы доказать, что шифротекст построен правильно, например, то это будет делаться с помощью открытого ключа. Но если вы захотите провести анонимный платёж, то в идеале не захотите раскрывать, с помощью какого открытого ключа что-то было зашифровано. Вы захотите просто сказать: "Этот шифротекст построен правильно". И нами предлагается способ, благодаря которому вы сможете доказать, что шифротекст построен правильно с использованием некоторого открытого ключа, который при этом вы раскрывать не станете. То есть, при расшифровке вы сможете сказать: "Я не скажу вам, в соответствии с каким открытым ключом зашифрован текст, какой ключ дешифрования я использую, но в нём содержится вот это сообщение". Таким образом, мы отделяем возможность идентификации открытого ключа от содержания шифротекста, которое хотим доказать.

Я вновь обращу ваше внимание на то, что это обзор на очень высоком уровне, и я пропускаю 99% деталей. Продолжим и вернёмся к блокчейну. В общих чертах система работает так: Элис не проводит прямую транзакцию, чтобы перевести средства Бобу. Вместо этого Элис платит доллар за то, чтобы ей разрешили разместить монету в блокчейне. А позже Боб сможет зайти в блокчейн и сказать: "Вот, это моя монета", и забрать её. И если мы хотим обеспечить анонимность, нам нужно, по сути, скрыть получателя монеты в момент, когда Элис помещает монету в блокчейн. А когда Боб забирает её, нам нужно скрыть, какую именно. Таким образом, даже Элис не должна быть в состоянии сказать, что та монета, которую она разместила в блокчейне, была получена Бобом.

Что в этом случае представляет собой монета в системе? А монета представляет собой шифротекст, зашифрованный с помощью открытого ключа получателя. То есть Элис шифрует что-то, используя открытый ключ Боба - это и будет монетой. И то, что зашифровывается, - это идентификатор транзакции. Но этот идентификатор будет особенным, поскольку если вы посмотрите на него со стороны, не будучи Элис или Бобом, то он будет выглядеть как случайная битовая строка. Но Элис и Боб будут знать, что это высокоструктурированная строка, содержащая информацию.

Для тех, кто немного знаком с криптографией: идентификатор транзакции будет представлять собой обязательство по ряду значений, и это впоследствии поможет Элис доказать, что монета в некотором смысле построена правильно, потому правильно построены зафиксированные в ней значения. А когда Боб заберёт монету, он сможет доказать, что ему разрешено делать это, что монета не была взята ранее, опять же потому, что у неё есть некая секретная структура, которая известна только им.

Так… мы забежали слишком далеко. Да, я не стану пускаться в подробности, но, по сути, именно данный идентификатор транзакции позволит Бобу выявить факт двойной траты. То есть в идентификаторе транзакции будет что-то, на что Боб сможет посмотреть и сказать: "Я этого не видел ранее. Должно быть, это первый раз, когда монета используется для оплаты конкретно мне".

Далее, ещё одна вещь, - и здесь мы переходим на территорию, которая могут быть менее изучена присутствующими, - это единожды считываемая карта с сильным свойством забывчивости. Что это означает? Забудьте на секунду о блокчейне и просто представьте, что есть Элиса, и есть массив, например массив памяти. И Элиса может производить операции с ячейкой массива. Например, Элис может дать команду: "Прочитать запись номер четыре" и получить нужное значение. Затем она может указать: "Сохранить какое-нибудь значение в записи номер семь". И это будет сделано.

Теперь представим ситуацию, в которой есть некий злоумышленник, наблюдающий за этой процедурой. Он видит, что Элис делает с массивом памяти. То есть, нам необходимо как-то скрыть эту информацию. Можно было бы зашифровать массив. При этом у Элис был бы ключ для расшифровки, и она получала и отправляла бы зашифрованные записи. То есть, совершала операции с зашифрованным массивом.

Но если злоумышленник посмотрит на схему доступа, на то, чем занимается Элис, то этого будет недостаточно, потому что сама схема доступа может дать информацию о том, что делает Элис. Элис, постоянно считывающая первую запись, явно отличается от Элис, считывающей другие записи. Поэтому простое шифрование значений не позволяет скрыть всю необходимую информацию.

Но есть способ скрыть даже ту информацию, которая вытекает из схемы доступа. Это карты с сильным свойством забывчивости или сокращённо ORAM. Такую карту можно представить как структуру данных, представляющую собой массив, но теперь, когда злоумышленник будет просматривать запросы на считывание и запись в этой структуре данных, он не сможет сказать, какие ячейки при этом задействовала Элис, у него не будет ни малейшего понятия об этом. Чтобы понять, как это работает, просто представьте себе один неэффективный способ - простое линейное сканирование массива всякий раз, когда выполняется какая-то операция. И когда вы хотите прочитать первую запись, вы просто сканируете весь массив. И всё. Злоумышленник увидит, что вы сканируете весь массив, и не будет знать, что вы сделали. При этом вы просматриваете именно ту запись, которую хотели.

В данном случае проблема заключается в том, для получения доступа всего к одной ячейке массива приходится читать весь массив. Это крайне неэффективно. Поэтому ORAM, по сути, предлагает и то, и другое. Это может быть реализовано эффективно и обеспечить надлежащий уровень приватности.

А работает это так: каждый раз при обращении к ячейкам выполняется несколько небольших перестановок. И если я хочу прочитать в массиве запись под номером четыре, то в моей структуре данных ORAM она будет находиться под номером семь. Я прочитаю её, а также прочитаю несколько фиктивных значений. Затем я немного перемешаю их и запишу обратно. Но всё равно я буду работать с лишь очень небольшой частью общей структуры данных. И такая незначительная перетасовка элементов полностью скрывает всю информацию. В частности, если у вас есть массив длины n, то для получения гарантии безопасности вам нужно прочитать не одну ячейку массива, но экспоненциально меньше ячеек массива, чем при полном линейном сканировании. Так что вам придётся прочитать совсем немного, ну или, надеюсь, не слишком много. Ну а полилогарифм - это логарифм от некоторой константы. Думаю, это понятно.

Итак, в чём же заключается высокоуровневая идея предлагаемого нами решения? Она заключается примерно в следующем. Допустим, Элис снова хочет разместить монету, а Боб хочет получить её. Теперь наш блокчейн уже будет не просто реестром, в который записываются транзакции, но станет структурой данных ORAM. И когда Элис захочет перевести средства Бобу, она поместит зашифрованный идентификатор транзакции, - то есть использует наш формат, - поместит его в структуру данных ORAM. А когда Боб захочет забрать платёж, он просто укажет, какое место в структуре данных ORAM нужно считать. В данном случае интересным кажется сравнение с конструкцией той же Zcash. Если взять конструкцию на основе накопления, то вам нужно придётся производить вычисления для всех существующих записей, поскольку если не заглянуть в запись, то, грубо говоря, будет непонятно, та ли это монета, которую нужно взять. Но поскольку ORAM всегда немного перетасовывает элементы, Бобу уже не приходится скрывать записи, которые он просматривает. Он просто говорит: "Я просматриваю эту и ещё пять записей, и я могу доказать, что один из этих шифротекстов содержит мою монету". И даже несмотря на то, что это очень малая часть от всех данных в блокчейне, то в силу гарантий структуры данных ORAM вы всё равно не будете знать, какую ячейку считывал Боб. Таким образом обеспечивается анонимность всех монет в системе.

Это предельно упрощённое описание - я просто хочу в общих чертах описать проблемы, которые есть у этого подхода. И первая заключается в том, что описанный мной массив - это не совсем то, что нам нужно, потому что на самом деле нам не нужен массив памяти, куда я помещал бы свои транзакции. Это больше похоже на то, как если бы я просто клал монеты, а потом получал их. Это немного отличается от массива. Но если вы знакомы с механизмами, описанными в работах по ORAM, вы сможете всё изменить так, чтобы получить то, что нужно.

Ещё один момент: как я уже сказал, использование ORAM подразумевает некоторую перетасовку элементов при совершении операций. И вот тут-то приходит на помощь подход, основанный концепции комитетов. Если вы имеете дело с блокчейном, в котором консенсус основан на этой концепции, в этом случае задача решается комитетами. И эта задача, опять же, затрагивает лишь очень небольшой объём общей памяти, с которым приходится иметь дело за одну операцию.

И ещё одна вещь: у нас есть массив, элементы которого постоянно перетасовываются, и я говорю: "В одной из этих пяти ячеек лежит моя монета". И возникает вопрос: как узнать, где искать монету? И тут нам пригодится маяк случайности. Когда Элис совершит платёж, маяк случайности опубликует некоторое значение. Элис скажет: "Хорошо, я знаю, куда делась моя монета". А затем она сообщит это значение Бобу. А позже Боб или даже Элис скажет: "Я заплатил тебе тогда-то". Затем Боб также сможет использовать маяк случайности, чтобы повторно вычислить это значение, которое в свою очередь покажет, где в перетасованной памяти нужно искать монету.

Это крайнее упрощение всех деталей, и я рекомендую вам ознакомиться с работой, которая опубликована в Интернете. И по мере того, как вы будете углубляться, она станет очень технической, но её первые 10 страниц представляют собой очень, очень высокоуровневый обзор того, как всё это работает.

Спасибо за внимание, и вот ссылка на упомянутую работу.

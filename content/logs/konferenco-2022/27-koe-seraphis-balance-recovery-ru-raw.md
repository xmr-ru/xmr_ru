---
title: "koe - Восстановление баланса в рамках протокола Seraphis"
date: "2022-06-19"
categories:
  - "Стенограмма"
tags:
  - "MoneroKon 2022"
lead: "Monero Konferenco 2022 #MoneroKon2022 Лиссабон - День 2"
pager: true
toc: false
sidebar: "right"
---

{{< youtube id="kK8EJwmLdUw" autoplay="false" >}}

---

Привет всем. Я здесь, чтобы поговорить с вами о восстановлении баланса в рамках протокола Seraphis.

Итак, часть 1, разминочная. Что такое протокол транзакций и что означает парадигма enote? Итак, enote - это просто сумма, которой кто-то владеет. В случае с Bitcoin и в целом в прошлом, и в большинстве случаев, в принципе, их называют просто выходами или выходами транзакций. Транзакция в блокчейне - это событие, в рамках которого тратятся старые выходы enote и создаются новые. То есть, суммы и выходы enote, которые тратятся, превращаются в новые выходы enote, у которых появляются новые владельцы. А блокчейн - это последовательность транзакций, в которых средства передаются между пользователями.

Когда мы говорим о восстановлении баланса, речь идёт о том, что пользователи хотят узнать, какова общая сумма, которую они могут потратить на данный момент. Поэтому им необходимо идентифицировать новые выходы enote, которые появляются в реестре и принадлежат им, а также выяснить, были ли потрачены полученные ими в прошлом выходы enote, и если да, то куда. Баланс - это просто сумма, записанная в выходе enote, который ещё не был потрачен, и которым владеют пользователи.

Когда мы решаем, как построить enote, мы думаем о том, как скрыть его на различных уровнях, например, уровнях кошелька, которые могут иметь различные возможности считывания информации, содержащейся в выходе enote. Третья цель, о которой не особо задумывались в прошлом, это реализация «принципа наименьшего удивления». То есть, когда вы обнаруживаете в реестре принадлежащий вам enote, вас это не должно удивлять - ни тот факт, что, что он принадлежит вам, равно как и то, какому адресу он принадлежит. Найдя выход enote, вы не должны удивляться тому, что он не может быть потрачена из-за предыдущего полученного вами выхода enote и подобным вещам.

Сегодня мы будем много говорить о криптографии, поэтому определимся с терминологией. У нас есть точки на эллиптической кривой, есть скалярные величины, есть операции, есть генераторы и есть хеш-функции. Одна хеш-функция, на которую стоит обратить внимание - это хеш с ключом, который не используется в CryptoNote. Поэтому в схему Jamtis, используемую протоколом Seraphis, мы добавляем хеш с ключом, позволяющий хешировать, используя чётко определённый секретный ключ.

Давайте вспомним, как работают CryptoNote и RingCT. В данном случае мы используем подадреса - это как бы отличительная черта CryptoNote. Также мы используем приватный ключ просмотра, приватный ключ траты, и когда мы создаём адрес, мы используем индекс подадреса. Таким образом, пользователь, у которого имеются оба эти приватных ключа, ключ просмотра и ключ траты, может на их основе генерировать множество подадресов. И средства, полученные на любой из этих подадресов, можно увидеть с помощью тех же приватных ключей. Данная схема улучшает приватные свойства системы подадресов, позволяя пользователям указывать различные адреса различным людям. В результате такие люди, если они общаются между собой, не будут знать, что эти адреса принадлежат одному и тому же человеку.

На практике это реализуется путём расширения ключа траты индексом подадреса, модификатором, который является хешем ключа просмотра и индекса. В самом адресе, которые указывается другим людям, у нас имеется два публичных ключа. Мы используем так называемый ключ траты, который, на самом деле, является базовым ключом Диффи-Хеллмана, и он, как мы увидим, и используется как базовый ключ Диффи-Хеллмана. И ещё у нас есть ключ просмотра, который является публичным ключом Диффи-Хеллмана, и который в дальнейшем будет играть важную роль в восстановлении баланса. И тут важно отметить, что сам по себе приватный ключ просмотра является заменой Диффи-Хеллмана ключом траты, но непосредственно с ключом просмотра без модификатора индекса адреса.

Итак, когда мы создаём выход enote в рамках протокола CryptoNote или RingCT, весь процесс заключается в следующем. Нам даётся адрес, сумма, опциональный идентификатор платежа и индекс выхода этого enote для транзакции, в которую он будет помещён. Мы начинаем с создания эфемерного публичного ключа, и обычно эфемерный ключ выглядит как r_t, умноженный на генератор G, но в нашем случае мы создаём публичный ключ, умноженный на определённый пользователем базовый публичный ключ Диффи-Хеллмана, как в случае с ключом траты, принадлежащем пользователю. И что важно, это позволяет использовать базовый ключ Диффи-Хеллмана как функцию индекса подадреса. Таким образом, вы можете генерировать множество ключей, но к этому мы ещё вернёмся.

Затем следует производная Диффи-Хеллмана - это обычный элемент Диффи-Хеллмана, который вы обычно видите. Итак, у нас имеется эфемерный ключ, умноженный на фактический пользовательский ключ Диффи-Хеллмана, который в данном случае является ключом просмотра. Затем мы хешируем его, чтобы получить секрет отношений между отправителем и получателем. А затем мы используем этот секрет отправителя-получателя для завершения построения enote.

Далее у нас есть сумма, которая является обязательством Педерсена между секретом и суммой, сумма, замаскированная секретом, у нас есть сама сумма, зашифрованная секретом для получателя, чтобы позже он мог расшифровать или декодировать её, у нас есть одноразовый адрес, который указывает на владение этим выходом enote, поэтому, чтобы доказать факт владения таким выходом enote, когда вы соберётесь его потратить, вам будет необходимо подписаться этим адресом. Мы делаем это путём простого расширения пользовательского ключа траты с помощью секрета отправителя-получателя. Также недавно было реализовано одно дополнение - тег просмотра, который, как мы увидим, ускоряет процесс восстановления баланса за счёт всего одного байта. Также у нас есть идентификатор платежа, который представляет собой восьмибайтную строку и шифруется секретом отправителя-получателя... о, простите, просто производной Диффи-Хеллмана - мы экономим хеш, просто напрямую помещая туда производную. В настоящее время в одной транзакции можно использовать только один зашифрованный идентификатор платежа, поэтому только один получатель сможет использовать его. Таким образом, конечный выход enote - это адрес, обязательство, зашифрованная сумма, тег просмотра, опциональный зашифрованный идентификатор платежа, и эфемерный базовый или эфемерный публичный ключ, который будет использоваться для восстановления баланса.

Поговорим об образе ключа CryptoNote. Это немного трудно прочитать, но мы всё рассмотрим. Всё это приватный ключ, прикреплённый к одноразовому адресу. У нас есть секрет отправителя-получателя, и я думаю, что здесь не хватает хеша, но у нас есть секрет отправителя-получателя, основанный на производной Диффи-Хеллмана, у нас есть сам индекс выхода, затем у нас есть расширение подадреса и ключ траты. Таким образом, вся эта информация, каждая из частей ключа, выполняет различные функции. Так, у нас есть ключ траты, который является ядром механизма подтверждения обладания выходом enote, поэтому, чтобы подписать образ ключа, а также одноразовый адрес, необходимо иметь ключ траты. Затем у нас есть расширение индекса, которое используется для того, чтобы убедиться, что все ваши подадреса отделены друг от друга и не имеют различимых связей. Затем у нас есть расширение отправителя-получателя или расширение секрета, скрывающее от наблюдателей ключ траты статических подадресов. Таким образом, для создания образа ключа необходимо иметь все эти приватные ключи, потому что все они умножаются на хеш для указания на одноразовый адрес. В результате возникает взаимозависимость между образом ключа и одноразовым адресом. Это означает, что для создания образа ключа у вас должны быть все эти составляющие.

Теперь перейдём к восстановлению баланса. Сканирование просмотров - это то, что можно сделать, обладая только приватным ключом просмотра и зная публичный ключ траты адреса. Первое, что необходимо сделать —предварительно сгенерировать все эти ключи траты для имеющихся подадресов, на которых по вашему мнению могут находиться средства в вашем кошельке. Итак, в этом случае нам предлагается произвести некоторое сканирование, и здесь, наверху, приводится информация о сканировании. Итак, у нас есть выход enote со всей информацией, связанной с ним, у нас есть эфемерный ключ, и у нас есть индекс выходов транзакции. Поэтому мы предварительно генерируем все ключи, которые могут принадлежать этому выходу enote, создаём производную Диффи-Хеллмана с помощью эфемерного ключа, хранящегося в транзакции, для этого мы умножаем эфемерный ключ на наш приватный ключ просмотра и получаем производную, мы вычисляем тег просмотра как простой хеш непосредственно на основе производной Диффи-Хеллмана. Если тег просмотра не совпадает, мы немедленно прерываем процесс. Это улучшение должно быть реализовано в рамках следующего хардфорка. Размер тега просмотра равен одному байту. Поэтому только один из каждых 256 не принадлежащих вам выходов в блокчейне попадёт в эту ловушку. Мы добавляем этот тег, поскольку последующие операции довольно затратны. Поэтому, если мы сможем пропустить их в случае со многими прочими не принадлежащими нам выходами, мы сможем сэкономить время при сканировании.

Итак, далее мы берём хеш производной Диффи-Хеллмана вместе с секретом, а затем проверяем одноразовый адрес, сохранённый в выходе enote, на соответствие одному из наших предварительно сгенерированных ключей траты подадреса. Если его нет в предварительно сгенерированном списке, то мы прерываем процесс. Таким образом, это нарушение принципа наименьшего удивления, потому что мы можем владеть этим выходом enote, и получается так, что ключ траты подадреса, к которому он принадлежит, отсутствует в предварительно сгенерированном списке. Это определённым образом влияет на некоторых пользователей, не на большинство, а на некоторую часть, но это немного досадно, и, я считаю, было бы лучше, если бы таких досадных ситуаций не было. Вы также можете расшифровать ID платежа, и, полагаю, если он будет нулевым, вы просто проигнорируете его.

Часть вторая - восстановление суммы. На данном этапе, вероятно, если мы прошли тестирование ключа траты подадреса, то, как правило, всё у нас хорошо. Но, на всякий случай, мы расшифруем сумму и пересчитаем обязательство по сумме, чтобы убедиться, что оно не является неверным. И в результате мы получим выход enote, которым владеем. На данный момент у нас нет образа ключа, потому что для образа ключа требуется ключ траты, приватный ключ траты. Вот так происходит сканирование просмотров с помощью CryptoNote.

Теперь мы можем перейти к восстановлению баланса в рамках протокола Seraphis. Во многом то, о чём я буду говорить далее, похоже на то, что делается в CryptoNote. Но есть несколько критических отличий. И одно из них заключается в построении одноразового адреса в выходе enote в Seraphis. Если раньше одноразовый адрес представлял собой ключ, умноженный на генератор G, то теперь у нас есть два генератора X и U. Кроме того, в одноразовом адресе у нас есть два приватных ключа. Обязательства по сумме будут такими же, как в RingCT, а сумма будет так же зашифрована. Когда мы собираемся потратить enote, мы также вносим ещё несколько изменений: мы создаём представление выхода enote, который тратим. Тем не менее, маска одноразового адреса, замаскированная версия одноразового адреса, и обязательство по сумме не являются нашей основной темой. Однако образ ключа - это довольно важная вещь, на которую стоит обратить внимание. Итак, конструкция образа ключа в Seraphis - это U из одноразового адреса, ключ U, поделённый на ключ X U раз. Об этой конструкции мы поговорим позже.

Итак, в общих чертах о восстановлении баланса. Как правило, мы пытаемся воспроизвести одноразовый адрес - мы расшифровываем сумму, пытаемся воспроизвести обязательство суммы, и теперь у нас есть дополнительный этап вычисления образа ключа и его сохранения на будущее. Таким образом, весь этот первый этап восстановления принадлежности может быть выполнен с помощью основного ключа просмотра, о котором мы ещё поговорим. После этого этапа восстановления принадлежности, вы можете идентифицировать ключи траты, просто просмотрев все выходы enote в реестре и сопоставив образы ключей с локально сохранёнными образами ключей, которые были сгенерированы с помощью ключа просмотра. Так что всё это можно сделать, исключительно с помощью ключа просмотра, о котором более подробно будет говориться дальше.

На практике для реализации всего этого мы используем схему адресации Jamtis. Так что все эти вещи пока определены не достаточно хорошо, но Jamtis позволит сделать это надлежащим образом. Я хотел бы сразу уточнить, что большая часть из того, что есть в Jamtis, может быть применена к CryptoNote и RingCT вместе с несколькими небольшими элементами, предназначенными для Seraphis для построения одноразовых адресов и образов ключей.

Итак, вот структура ключа в Jamtis. Она немного сложнее, но наличие этих дополнительных ключей даёт нам более полный контроль над доступом к информации в процессе восстановления баланса. Итак, у нас есть основной ключ, который эквивалентен приватному ключу траты, затем у нас есть ключ просмотра баланса - эти два ключа являются главными - и далее у нас есть несколько производных ключей: секрет генерации адреса, который порождает секрет шифрованного тега, ключ поиска и получения и ключ разблокировки сумм. Отмечу, что ключ разблокировки сумм был добавлен всего два дня назад, но я считаю его важным.

А вот уровни кошельков, с которыми вы имеете дело при использовании всех этих ключей. Итак, мы имеем дело с основным ключом - в случае с полностью активированным кошельком, у нас есть уровень полного просмотра, уровень просмотра полученного, который позволяет просматривать только входящие enote, которые не были посланы самому себе, и о них мы поговорим позже, уровень поиска полученных ключей, на котором представлены предварительно обработанное результаты сканирования блокчейна, и уровень генерации адресов, позволяющий создавать адреса только для вашего аккаунта. Думаю, Джастин расскажет об этих уровнях и о том, как они влияют на пользователей, чуть позже.

Итак, у нас есть адреса Jamtis. Адреса Jamtis компактны - они содержат все уровни доступа к информации в очень компактной форме. Так что на распаковку уйдёт немного времени, но мы к этому ещё придём. Итак, первое примечание: мы уходим от терминологии подадресов и теперь говорим только об адресах. Просто для простоты. Итак, у нас есть модификаторы индексов адресов, которые, по сути, то же самое, что и модификаторы подадресов - они позволяют нам иметь много адресов с одинаковой структурой основного ключа или пользовательских ключей. Поэтому мы будем расширять наши ключи адресов с помощью модификаторов индекса.

Итак, здесь представлено содержимое нашего адреса. В Jamtis вместо двух у нас имеется три публичных ключа, что даёт нам более полный контроль над доступом к информации. Но здесь следует отметить, что ключ траты более не является базовым ключом Диффи-Хеллмана пользователя. Вместо этого мы заменили его на третий ключ, который является функцией модификатора индекса и ключа разблокировки сумм. Как мы увидим, для управления доступом к информации мы будем использовать обратный ключ Диффи-Хеллмана, как я его называю. Итак, мы снова можем начать с рассмотрения базового публичного ключа Диффи-Хеллмана. Также, как я уже сказал, у нас имеется модификатор индекса и ключ разблокировки суммы, а также публичный ключ Диффи-Хеллмана пользователя, ключ поиска и получения - это, по сути, базовый ключ Диффи-Хеллмана, использующий наш ключ поиска и получения. Так что единственное отличие состоит в добавлении ключа поиска и получения. Это очень похоже на ключ просмотра адреса в CryptoNote, который представляет собой приватный ключ просмотра, умноженный на ключ траты. Так что в данном случае у нас есть ключ поиска и получения, умноженный на базовый публичный ключ. Также у нас есть ключ траты, который представляет собой основной ключ, умноженный на U, ключ просмотра баланса, то есть основной, самый главный ключ просмотра, умноженный на X, а затем дополнительный модификатор индекса адреса или расширение ключа траты. Таким образом, у нас есть два расширения или два модификатора. Расширение ключа траты переносится ключ траты, а приватный ключ адреса переносится на ключ Диффи-Хеллмана.

Четвёртая часть адреса - это тег индекса адреса, который играет важную роль в процессе восстановления баланса. Итак, тег индекса адреса - это просто зашифрованный с помощью небольшого MAC индекс адреса, который затем сохраняется вместе с адресом. Так что сейчас я реализовал 16-байтовый индекс адреса с двухбайтовым MAC. Причина такого большого размера тега индекса, 18 байт, состоит в том, что с помощью 16-байтовгого индекса адреса вы можете надёжно и уверенно генерировать любой случайный индекс, не опасаясь какого-либо конфликта. Это также соответствует размеру uuid, который составляет 16 байт. Так что, надеюсь, это подойдёт для большого количества вариантов использования. Двухбайтовый MAC обеспечивает потенциальную совместимость или размер, позволяющий в перспективе повысить производительность.

Итак, здесь показана обычная конструкция выхода enote в рамках схемы Jamtis. В этом случае у нас есть два вида enote - нормальные выходы enote и отправляемые самим себе выходы enote, и позже я расскажу, в чём состоит различие. Итак, если у нас имеется адрес пользователя, в котором содержатся ключи адреса и тег адреса, мы имеем сумму и эти контекстные данные входа. Контекстные данные входа - это интересное дополнение, о котором я сейчас расскажу. Итак, контекстные данные обычно представляют собой хеш всех образов ключей, которые являются входами транзакции, в которой создаётся этот enote. В том случае, если это coinbase-транзакция, это будет хеш высоты блока такой транзакции. Итак, у нас есть эфемерный ключ выхода enote, который представляет собой эфемерный приватный ключ, помноженный на базовый ключ Диффи-Хеллмана, указанный пользователем. Вместо генератора, как это обычно бывает в случае с ключом Диффи-Хеллмана, у вас есть заданный пользователем базовый ключ для эфемерного публичного ключа. У вас также есть производная Диффи-Хеллмана, которая является секретом в обмене Диффи-Хеллмана между эфемерным приватным ключом и публичным ключом Диффи-Хеллмана, определяемым в адресе пользователя. У нас также есть секрет отправителя-получателя, который представляет собой функцию производной Диффи-Хеллмана. Также для надежности мы используем эфемерный публичный ключ, содержащий контекстную информацию входа. Таким образом, секрет отправителя-получателя связан со входами транзакции. Поскольку контекстные данные входов всегда уникальны, равно как и образы ключей и высота coinbase-транзакций уникальны, секреты отправителя-получателя тоже будут уникальны, и это означает, что полученные составляющие выхода enote в блокчейне будут уникальными, если только enote не окажется искажённым. Но в подобном случае пользователь при сканировании блокчейна просто не обнаружит такой выход enote.

Теперь подробней. Как правило, у нас есть обязательство по сумме, зашифрованная сумма, одноразовый адрес - эти три параметра, по сути,  будут теми же, что и в случае c RingCT с расширением или с секретом отправителя-получателя. При этом в одноразовый адрес мы включили обязательство суммы, связанное с одноразовым адресом, чтобы в тех случаях, когда контекстная информация входа будет искажена, пользователь, получающий такую контекстную информацию от злоумышленника, содержащуюся при этом в реестре, например, от стороннего сканера или узла, наверняка знал об этом. Если при этом они сотрудничают с тем, кто построил выход enote, чтобы вам попался вредоносный контекст входа, и вы посчитаете, что действительно владеете таким  enote, даже если в реальности контекст входа не будет соответствовать данным входов транзакции, а фактически будет относиться ко входам совершенно другой транзакции, в результате чего секрет отправителя-получателя будет дублировать то, что может быть найдено в другой транзакции, даже в этом случае одноразовый адрес будет продублирован только в том случае, если дублируется само обязательство по сумме. Таким образом, только если в выходе enote будет указана точно та же сумма, что и в предыдущей, другой транзакции, одноразовый адрес будет продублирован. Это означает, что если в блокчейне имеются дубликаты выхода enote, их суммы гарантированно будут одинаковыми. Если пользователь сможет обнаружить дубликаты выхода enote, их суммы гарантированно будут одинаковыми. Поэтому, мы также шифруем тег адреса и помещаем его в enote, а также, как обычно, используем тег просмотра.

Теперь поговорим о выходах enote, отправляемых самим себе. Когда вы создаёте транзакцию, чаще всего вы добавляете выход сдачи, иногда вы добавляете фиктивный выход, но всё это создаёте сами и отправляете себе. Таким образом, у нас есть возможность построения конструкции этих выходов, что обеспечивает более высокий уровень контроля над восстановлением информации, о чём мы поговорим позже.

Здесь звёздочками помочены те компоненты, которые строятся иначе. То есть, секрет отправителя-получателя будет отличаться. В данном случае мы вообще не производим замены Диффи-Хеллмана. Мы не создаём производной Диффи-Хеллмана, кроме как для тега просмотра. Для секрета отправителя-получателя производная не создаётся. Вместо этого мы создаём хеш с ключом для некоторой контекстной информации. Отправляемый себе выход enote, эфемерный публичный ключ, который хранится в выходе enote, и контекст входа связаны с ключом просмотра баланса. Это означает, что получатель, который создал его для себя, может восстановить секрет отправителя-получателя не реализуя замены Диффи-Хеллмана.

И я забыл кое о чём упомянуть. У нас есть обязательства по сумме и зашифрованная сумма, и мы включаем их как основу, можно называть их основой замены Диффи-Хеллмана. А базовый ключ Диффи-Хеллмана или обратный ключ Диффи-Хеллмана, по сути, является эфемерным приватным ключом, умноженным на генератор G.

Так что, эфемерный публичный ключ можно рассматривать в качестве обратного эфемерного ключа для данного ключа, который интегрируется в обязательство по сумме и зашифрованную сумму. Таким образом, приватный ключ пользователя для перехода от эфемерного публичного ключа к этому интегрированному ключу является ключом над ключом разблокировки суммы, который мы видим здесь, поэтому ключ, находящийся над ключом разблокировки суммы умножается на приватный ключ адреса. Так… не туда перешёл. Так что, это своего рода двунаправленная эфемерная замена.

Но в случае с отправляемыми себе выходами enote этого нет, потому что сам секрет отправителя-получателя связан с ключом просмотра баланса, который является как бы главным для всех просмотров. Поэтому нам не нужно это интегрировать. Итак, у нас есть обязательства по сумме, зашифрованная сумма, одноразовый адрес - всё то же самое. В данном случае мы производим «грубое» шифрование тега адреса, индекса адреса, вместо шифрования выхода enote или тега адреса, потому что секрет отправителя-получателя снова связан с основным главным ключом просмотра баланса. Поэтому мы можем просто зашифровать индекс адреса и получить те же свойства, что нам требуются. Кроме того, у нас имеется тег просмотра, который будет таким же, как и в случае с обычным выходом  enote, у нас есть ключ Диффи-Хеллмана, который входит в тег просмотра, и производная Диффи-Хеллмана, которая также входит в тег просмотра. Также отмечу, что в обоих случаях зашифрованный тег адреса и тег просмотра привязаны к одноразовому адресу, и это помогает обеспечить уникальность во всех или почти во всех случаях. Итак, в окончательном варианте мы имеем, как уже было сказано, обязательство по сумме, зашифрованную сумму, одноразовый адрес, зашифрованный тег адреса, тег просмотра и эфемерный публичный ключ.

Итак, теперь у нас есть ключи Jamtis или образы ключей. В данном случае всё отличается от того, как это происходит в CryptoNote. Все части, связанные с просмотром, находятся в знаменателе, а числитель - это основной ключ. Поэтому здесь важно то, что основной ключ, помноженный на U, это просто публичный ключ, статический публичный ключ, и если вам известен ключ просмотра баланса, вы можете восстановить всё, что находится в числителе, а затем произвести обратное умножение на ваш предварительно сохраненный основной ключ и получить образ ключа. Так мы разделяем требования к просмотру и подписанию. Для просмотра вам нужен ключ просмотра баланса и этот публичный ключ, а для подписания образа ключа вам нужен ключ просмотра баланса и главный приватный ключ. Таким образом, образ ключа также связан со всей остальной информацией - обязательством по сумме, эфемерным ключом, индексом адреса и контекстом входов транзакции.

У нас уже мало времени, но я продолжу. Итак, у нас есть оптимизированный вариант с двумя выходами, позволяющий ускорить восстановление баланса. Это то, что мы используем в рамках текущего протокола RingCT. Большинство транзакций имеют только два выхода - выход для адреса назначения, нормального адреса назначения, и выход сдачи, возвращающий средства обратно вам. В некоторых случаях также используется фиктивная сумма, которая является нулевой и передаётся в качестве сдачи. В таких случаях возможна дальнейшая оптимизация. Мы можем поместить в транзакцию только один эфемерный публичный ключ, вместо одного ключа на каждый выход. То есть, мы будем использовать только один, общий для двух выходов ключ. Это можно сделать в том случае, если второй выход будет отправляться самому себе, потому что в таких случаях вам будет известен ключ поиска-получения, и вы сможете перестроить его для получения производной Диффи-Хеллмана. Итак, вы получаете эфемерный ключ для отправки выхода не самому себе, то есть, для отправки другому обычному получателю, а затем вы просто умножаете отправляемый себе выход или свой собственный ключ поиска-получения на этот другой эфемерный публичный ключ, чтобы получить производную Диффи-Хеллмана для вашей транзакции. В случае с отправляемыми себе выходами она используется только для тега просмотра.

Но существует ли риск дублирования, который повлияет на приватность при повторном использовании эфемерного публичного ключа? Прежде всего, мы делаем это только в том случае, если у нас есть хотя бы один из двух отправляемый себе выход. Таким образом, дублирование может произойти только в том случае, если у нас есть два отправляемых себе выхода одного и того же типа. Поскольку мы используем тип отправляемых себе выходов в качестве разделителя доменов, секрет отправителя-получателя привязан к самому типу. Поэтому мы никогда его не получим. Мы можем получить дублированные секреты отправителя-получателя, только если у нас в транзакции присутствуют отправляемые себе выходы одного и того же типа. Поэтому нам нужны два отправляемых себе выхода одного типа. В транзакциях образы ключей, извините, не образы ключей, а одноразовые адреса выходов должны быть уникальными в пределах одной транзакции, но не в пределах всего реестра, потому что это влечёт за собой DDoS - в пределах транзакции все одноразовые адреса должны быть уникальными. И поскольку одноразовый адрес и два тега привязаны к одноразовому адресу, они тоже будут уникальными, но обязательство по сумме может дублироваться, если у вас есть отправляемые себе выходы одного типа. Но этого достаточно легко избежать, запретив отправлять себе два выхода одного типа. В любом случае не вижу никакого смысла в двух выходах сдачи, так что это легко сделать. Обратите внимание, что вы можете иметь два отправляемых себе выхода одного типа с разными суммами, и обязательства по сумме в этом случае не будут идентичными. Так что, возможно, это нормально, но поскольку суммы малы, вы можете методом перебора проверить равенство самой маски. Так что это, вроде как, не имеет значения.

Итак, вот правила, определяющие, когда вы можете или когда вы должны добавить дополнительный выход. На этом слайде я попытаюсь объяснить верхнюю часть. Мы хотим, чтобы все транзакции имели как минимум два выхода и как минимум один отправляемый себе выход. И это важный вариант оптимизации, которую мне помог найти Джастин. Когда мы ищем наши потраченные выходы enote, когда мы пытаемся определить, какие из них мы потратили, мы хотим искать их только в тех транзакциях, которые мы создали. Так что, если все созданные нами транзакции имеют хотя бы один отправляемый себе выход, это гарантирует, что хотя бы один выход будет совпадать с тегом просмотра, а значит, если мы будем следовать этому правилу и искать только в тех транзакциях, где есть хотя бы один совпадающий тег просмотра, просматривать в этих транзакциях образы ключей, то чтобы найти все потраченный нами выходы enote, нам будет достаточно этих образов ключей. Я понимаю, что уже перебрал по времени, поэтому буду продолжать, пока кто-нибудь меня не остановит. Таким образом, это важная оптимизация, позволяющая уменьшить количество передаваемых при удалённом сканировании данных.

Часть пятая. Мы поговорим о фактическом рабочем процессе восстановления баланса, который сложнее, чем в случае с CryptoNote, поскольку мы имеем более полный контроль над доступом к информации.

Итак, первая часть сканирования - это поиск-получение. Здесь у вас есть только ключ поиска-получения - это приватный ключ k_fr. Это как бы этап предварительной обработки перед сканированием. Это самый затратный этап сканирования. Итак, мы, как обычно, получаем производную Диффи-Хеллмана, и эта производная будет одинаковой для обычных и отправляемых себе выходов. Поэтому следующий шаг, на котором мы выполняем проверку тегов просмотра, будет одинаковым для обычных и отправляемых себе выходов enote. Важно отметить, что если в нашей транзакции имеется два выхода, то для этой транзакции производная Диффи-Хеллмана будет вычисляться только один раз. Вот здесь-то и приходит на помощь оптимизация с двумя выходами. Для транзакции с двумя выходами мы вычисляем производную Диффи-Хеллмана только один раз.

Как только мы вычислим производную, мы создадим тег просмотра и прервём процесс, если это не удастся, если мы не сможем воспроизвести его. Затем мы создаём обычный секрет отправителя-получателя и используем его для расшифровки зашифрованного тега адреса, который хранится в выходе enote в реестре. Таким образом мы получаем номинальный тег адреса. Сам по себе ключ поиска-получения не может использоваться для расшифровки тега адреса, чтобы найти индекс адреса внутри него. Но тег адреса является статическим значением адреса, которому принадлежит выход enote. Поэтому тот, у кого есть ключ поиска-передачи, может сопоставить теги адреса с набором сохранённых или известных пользователю адресов. Это может быть использовано для уведомления нелокального пользователя, когда он потенциально получит выход, путём сопоставления тега адреса с предварительно определённым списком.

Теперь поговорим о сканировании баланса просмотра, нормальном процессе. Это первое, что вы делаете, когда получаете выход enote, отмеченный в процессе поиска-получения. Я не стану подробно рассматривать другие уровни, обозначенные слева. Итак, в данном у случае у нас есть приватный ключ просмотра баланса и главный публичный ключ. И, безусловно, мы можем использовать ключ просмотра баланса для получения всех остальных приватных ключей, используемых для восстановления баланса. Итак, у нас есть номинальный или номинально принадлежащий нам выход enote, отмеченный в процессе поиска-получения, и мы хотим посмотреть, действительно ли он принадлежит нам. Поэтому первое, что мы делаем —расшифровываем тег адреса, что позволяет получить индекс адреса. И это очень эффективный шаг, потому что расшифровка происходит очень быстро, если сравнивать с операциями на эллиптической кривой. Итак, мы расшифровываем номинальный тег, полученный при сканировании в процессе поиска-получения. И если расшифровка не удается, мы прерываем процесс. Так как размер MAC в данном случае равен двум байтам, и на данный момент мы прошли через целых три байта фильтрации. Так что в подавляющем большинстве случаев, если мы пройдем через эти три байта фильтрации, то есть, тег просмотра, а затем тег адреса, через эти два этапа, мы, вероятно, являемся владельцами выхода enote. Таким образом, в случае с очень многими выходами enote из реестра, не принадлежащими нам, остальная часть сканирования не проводится.

Таким образом, расшифровка тега адреса влияет на процесс сканирования по двум важным направлениям. Во-первых, MAC является важным фильтром, обеспечивающим эффективность при обработке информации, полученной при сканировании в процессе поиска-получения, что значительно влияет на скорость восстановления баланса локальным пользователем, который загружает предварительно отсканированную информацию из службы поиска-получения или любой другой. Кроме того, мы получаем сам индекс адреса, что означает, что мы можем выполнять остальные операции по восстановлению баланса непосредственно по этому индексу адреса, не имея предварительно сгенерированного списка адресов для сравнения, поскольку мы можем просто использовать сам индекс адреса непосредственно для восстановления.

Хорошо, продолжим. Итак, мы создаем соответствующий секрет отправителя-получателя. В этом случае мы можем либо повторно использовать производную Диффи-Хеллмана, если она ещё есть у нас, либо воссоздать её, если она была утеряна. Поэтому мы не хотим передавать секрет Диффи-Хеллмана или секрет отправителя-получателя по сети. Поэтому полученная информация не включает его, и, как только мы пройдем через фильтр индексов адресов, мы сможем без особых затрат восстановить производную Диффи-Хеллмана. Итак, мы получаем секрет отправителя-получателя и используем расшифрованный индекс адреса для восстановления одноразового адреса выхода enote, который может принадлежать нам. Если нам не удается восстановить одноразовый адрес, то мы прервём процесс, поскольку, вероятно, фильтрация не удалась, и мы не владеем этим выходом.

И здесь у нас есть пунктирная линия с маленькой уродливой пометкой: «Ключ поиска получения плюс ключ генерации адреса», то есть, вы можете дойти до этой линии, используя только ключ поиска получения и ключ генерации адреса, поскольку с помощью ключа генерации адреса мы можем восстановить одноразовый адрес, используя только это расширение ключа траты и секрет отправителя-получателя, потому что у нас есть k_vb X плюс k_m U. Так что, если объединить эти два уровня кошелька, в процессе сканирования можно дойти только до этой точки. Поэтому добавление ключа разблокировки суммы было очень важным, так как без такого ключа мы не смогли бы пройти весь путь до второй синей линии внизу, до восстановления суммы, о чём я буду говорить чуть позже. Итак, ключ разблокировки суммы доводит вас до этой строки, а затем добавление или получение ключа разблокировки суммы доводит вас до этой линии, но без ключа разблокировки суммы вы доходите только до этой, где вы определяете, какой индекс адреса принадлежит выходу enote, что соответствует тому, что соответствует ожидаемому от этих двух ключей. Таким образом, ключ генерации адреса позволяет просматривать адреса, а ключ поиска-получения может показать вам номинальный адрес выхода enote, который был построен нормальным образом, выхода отправляемого не самому себе.

Итак, продолжим - восстановление суммы. Здесь мы имеем интегрированный ключ, о котором я уже говорил, это своего рода обратная замена Диффи-Хеллмана с обратным K_e в адресе, базовый ключ Диффи-Хеллмана пользователя, получателя. Мы производим обратную операцию с эфемерным ключом, чтобы получить эфемерный базовый ключ или, как его еще называют, интегрированный ключ, чтобы расшифровать суммы и восстановить обязательства по суммам. Таким образом, этот обратный ключ Диффи-Хеллмана обеспечивает две важные вещи: возможность считывать суммы с ключом разблокировки суммы в дополнение, конечно, к ключу генерации адреса для модификатора индекса адреса. Так что в дополнение к получению доступа к информации, это позволяет предотвратить атаку Януса, к которой уязвим протокол CryptoNote с его подадресами. Атака Януса заключается в том, если злонамеренно создать из компонентов двух разных подадресов выход enote, можно будет связать два подадреса друг с другом. А затем, если пользователь восстановит его и уведомит отправителя о том, что он его получил, то отправитель будет знать, что два подадреса, которые он использовал для построения enote, принадлежат одному и тому же пользователю. В нашем случае мы восстанавливаем всё на базе самого индекса адреса. То есть, индекс адреса, который мы получили из тега адреса, используется для реконструкции одноразового адреса и обязательства по сумме. Поэтому невозможно объединить два отдельных адреса для создания выхода enote, который можно будет успешно восстановить. Таким образом, этот маленький трюк с обратным ключом Диффи-Хеллмана является довольно мощным.

Итак, выше по этой синей линии находится то, что может сделать валидатор платежа. Это уровень поиска-получения, уровень кошелька, поэтому у валидатора платежа есть ключи генерации адреса, поиска получения и разблокировки суммы, а также этот публичный ключ, который может быть использован для восстановления суммы, одноразового адреса. Таким образом, до этого момента валидатор платежа может найти все нормальные выходы enote, отправленные пользователю, и прочитать индекс адреса и сумму.

Ещё один момент, связанный с индексом адреса. Поскольку его размер составляет 16 байт, это позволяет нам отказаться от системы идентификаторов платежей, потому что идентификатор платежа как бы встраивается в сам индекс адреса. Думаю, мы ещё поговорим об этом подробнее.

Но продолжим об образах ключей. Это то, что позволяет сделать только ключ просмотра баланса. Поскольку наш одноразовый адрес в сегменте X содержит ключ баланса просмотра, нам надо переместить эту часть из сегмента X, инвертировать её в сегмент U с образом ключа. Таким образом, образ ключа является инверсией всего этого механизма просмотра, помноженной на статический ключ. Поэтому, если у вас есть ключ просмотра баланса, вы можете построить образ ключа. Итак, если образ ключа присутствует в блокчейне, значит, выход enote был потрачен, и вы можете узнать это с помощью ключа просмотра баланса, который, конечно, может быть использован, как я уже говорил, для получения всех других ключей, разблокировки всей остальной информации и получения образа ключа. Итак, в результате мы получаем выход enote, эфемерный ключ, контекст входа, индекс суммы, образ ключа, и вы теперь можете с уверенностью сказать, что это нормальный тип, потому что всё прошло успешно.

Теперь мы продолжаем восстановление баланса с оправленным самому себе выходом. Через несколько слайдов я расскажу о цикле, посредством которого мы приходим к этому. Итак, мы ищем enote, который может быть отправленным самому себе выходом. То есть, тега просмотра в транзакции должен совпадать с одним из наших образов ключа. То есть, образ ключа выхода enote, предшествующего этому enote - какой-то предыдущий enote, которым мы владеем, произвёл образ ключа, который появился в этой транзакции. И данная транзакция имеет совпадающий тег просмотра. И теперь мы знаем, что это может быть отправленный самому себе выход, и будем рассматривать его как потенциально таковой. Итак, мы можем сказать, что у нас есть обычный выход enote с контекстом входа эфемерного ключа. Если бы мы получили информацию на этапе поиска-получения, единственной дополнительной составляющей стал бы тег номинального адреса, но он не будет использоваться на этом этапе сканирования.

Итак, в первую очередь мы создаём хеш с ключом для контекста входа эфемерного ключа и типа отправляемого себе выхода, который мы должны проверить, потому что типов может быть несколько. Таким образом, у нас есть сдача, есть фиктивные отправленные самому себе выходы, если сдача является нулевой или отправленные себе выходы, когда мы просто занимаемся «вспениванием». На данный момент у нас есть эти три отличия. Так что нам придется проверить все три. Но это не будет затратно, поскольку следующее, что мы сделаем после того, как у нас появится секрет отправителя-получателя, мы расшифруем тег адреса. Мы просто расшифровываем тег адреса для получения соответствующего индекса. И если MAC будет равен нулю, как и ожидалось, то мы продолжим, а если он будет недействителен, то мы можем попробовать новый тип отправленного себе выхода. Так что, эти два процесса не требуют особых затрат - мы просто создаём хеш и выполняем XOR для всех типов, за исключением случая, когда MAC не является несоответствующим, даже если мы им не владеем. В этом случае мы производим реконструкцию одноразового адреса, то есть, делаем то же самое, что и при обычном сканировании с реконструкцией. Если результат отрицательный, мы прерываем процесс или пробуем новый тип отправленного себе выхода. Если всё проходит успешно, то, вероятно, выход принадлежит нам, если только не произошло что-то ужасное во время построения выхода enote.

Теперь мы переходим к восстановлению суммы. Здесь не используется интегрированного ключа, потому что атака Януса не имеет смысла. Не знаю, как тут появилось это примечание. Интегрированный ключ не используется, поскольку секрет отправителя-получателя уже является функцией ключа просмотра баланса, так что если мы сможем зайти так далеко, то вопрос о доступе к информации отпадёт, потому что только ключ просмотра баланса позволяет выполнить эту часть сканирования отправленных самому себе выходов. Поэтому мы расшифровываем их, восстанавливаем обязательство суммы, просто чтобы убедиться, что оно сформировано надлежащим образом, и воссоздаем образ ключа, как мы это делали раньше, проверяем образ ключа, и если мы где-то находим этот образ ключа, значит, enote был потрачен. Итак, мы имеем тот же результат: контекст входа эфемерного ключа, индекс суммы, образ ключа, и в этом случае у нас есть тип отправленного себе выхода, который прошёл проверку.

Итак, у нас есть два последних слайда, где всё это объединяется в процесс, с помощью которого мы обрабатываем реестр, то есть, информацию, содержащуюся в реестре. Я реализовал его как сканирование фрагментов. Итак, у нас есть фрагмент, являющийся просто некоторым набором транзакций либо из какого-то ряда блоков, либо это из пула транзакций, может быть откуда-то вне блокчейна, как в случае с атомными свопами, или откуда-то ещё. Итак, в процессе поиска-получения мы сканируем этот набор транзакций и, соответственно, сканируем все выходы enote, содержащиеся в этих транзакциях. Таким образом, у нас есть основные записанные выходы enote, которые являются простыми выходами enote с совпадающим тегом просмотра в прошлом, и они также содержат тег номинального адреса, соответствующий этапу поиска-получения, а также некоторую контекстную информацию о том, откуда появились эти выходы enote. А затем на основе транзакций с совпадающими тегами просмотра, то есть у которых все выходы enote находятся в векторе найденных enote для каждой из этих транзакций, мы записываем образы ключей, а также, откуда они были получены. Затем, обработав фрагмент, чтобы просмотреть баланс, мы завершим или закончим сканирование фрагмента. Сначала мы смотрим на образы ключей во фрагменте и определяем, есть ли среди старых выходов enote, которые мы хранили в локальном кошельке, те, что были потрачены в этом фрагменте. Если да, то мы сохраняем идентификатор транзакции, в которой они были потрачены.

Затем мы проводим нормальное сканирование. Мы не сканируем все найденные во фрагменте выходы enote. Так что всё происходит очень быстро, благодаря расшифровке тегов адреса. Если какой-либо из нормально отсканированных во фрагменте выходов enote был потрачен, то мы сохраняем идентификатор соответствующей транзакции. Затем мы просматриваем все идентификаторы транзакций, которые были отмечены как имеющие образы ключей траты. Таким образом, все транзакции с образами ключей траты - это транзакции, созданные нами, поэтому в них могут присутствовать отправленные самим себе выходы. Поэтому мы перебираем сохранённые идентификаторы, чтобы просканировать все совпадающие теги просмотра в этих отмеченных транзакциях на предмет наличия отправленных самим себе выходов enote. И вновь это происходит быстро благодаря метке адреса или расшифровке. Если какие-либо из отправленных самим себе выходов enote были потрачены позже во фрагменте, то мы повторяем цикл, чтобы пройти весь фрагмент и убедиться в том, что мы ничего не пропустили. Вот таким образом происходит обработка фрагментов.

Когда речь заходит о самом реестре, то обработка происходит по одному фрагменту за раз, так что это напоминает последовательную обработку фрагментов. Итак, у нас есть фрагмент реестра, который представляет собой просто фрагмент, содержащий выходы enote - найденные в процессе поиска-получения, отсканированные выходы enote из какого-то ряда блоков. Мы также записываем идентификатор блока, который предшествует ряду блоков, чтобы мы могли проверить, что при сканировании каждый из фрагментов является смежным со следующим фрагментом. Это делается на случай, если в процессе сканирования произойдут изменения. Кроме того, это позволяет произвести проверку смежности с нашими локально хранящимися идентификаторами блоков в случае реорганизации хранящихся блоков, которые мы уже отсканировали.

Итак, итак, в процессе сканирования мы сканируем фрагменты реестра, содержащие выходы enote, пока не останется ни одного необработанного фрагмента. И, конечно, мы сканируем фрагменты, а не весь реестр целиком, из соображений эффективности. Мы проверяем смежность фрагментов, и нам придётся сканировать их заново, если смежность будет нарушена, будут какие-то несовпадения, ведь это будет означать, что произошла реорганизация. Поэтому нам придётся вернуться и провести повторное сканирование. Существуют некоторые сложности, связанные с тем, полностью или частично вы сканируете. Это проблема реализации. После выполнения цикла в блокчейне, когда мы обрабатываем весь реестр последовательными фрагментами, мы обрабатываем все транзакции в пуле транзакций как один фрагмент. А затем мы выполняем ещё один последующий цикл, сканируя реестр. Таким образом, мы выполняем последующий цикл в том случае, если неподтверждённый фрагмент устарел. Это асинхронный процесс, поэтому блок может проскочить между этим циклом, выполняемым в блокчейне, и неподтвержденным фрагментом. Поэтому мы реализуем последующий цикл, чтобы убедиться, что мы ничего не пропустили, поскольку нас больше заботит неподтверждённый материал, чем неподтвержденный. Так что ничего страшного, если неподтверждённые данные устарели. Затем, просканировав всё надлежащим образом, мы обновляем наше локальное хранилище. Мы выбрасываем все ранее существовавшие неподтверждённые записи, которые находятся выше точки согласования с текущей версией блокчейна, а затем заменяем и обновляем все данные. И это конец моей презентации.

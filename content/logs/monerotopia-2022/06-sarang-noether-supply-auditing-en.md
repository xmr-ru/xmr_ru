---
title: "Aaron Feickert (Sarang Noether) - Supply Auditing"
date: "2022-05-11"
categories:
  - ""
tags:
  - ""
lead: "Aaron Feickert (Sarang Noether), a Research Contributor speaks about Supply Auditing: What it is (and isn't), at the Monerotopia 2022 #XMR4ALL event!"
pager: true
toc: false
sidebar: "right"
---

{{< youtube id="aHv2gq4Wm5I" autoplay="false" >}}

---

_**Moderator:**_ The next one we have is Sarang. Sarang, this guy — he's a god in the space. So I hope you're appreciating this. He's going to be talking about audibility. Is that correct, right? This is one of the main things that comes up, this is one of the main criticisms that comes up. People say: “Yeah, yeah, Monero is cool”. But those that like it's kind of more of the higher level criticism, right. So people that like know a little bit about it, they know a little bit about Bitcoin, they're BTC maxis. They're like: “Oh yeah, but you can't audit, you can't add up all the Monero with your TI-82 by looking at the transparent ledger”. No you can't do that. But we don't need to do that. And Sarang is going to explain why, and he'll get into that. And I leave it with you man.

_**Sarang:**_ Thank you so much, awesome, thank you. So yes, I'll be talking today about supply auditability, the idea of inflation in digital assets, including Monero and others, with some case studies. And I regret to inform you, I'm going to leave you disappointed with an answer. Oh man, it's subtle. But we'll get some good information along the way. I understand it's kind of hard to read the slides here, so I will break the corner rule of giving a presentation and make sure that I read everything on them as I'm talking about. So, click.

Sure, of course this is not professional advice or financial advice, and all that whatever. Click, thank you.

So first of all what do we mean when we talk about inflation, and what do we mean when we talk about supply auditability. They're related but the definitions kind of vary from person to person and project to project. So to start out with, when we're talking about digital assets, Monero and others included, we need to make sure that the value that is able to be spent in the system as a whole is what you expect it to be according to protocol rules. And again this could depend on the protocol, but oftentimes we have kind of some common things that we mean when we talk about this. So one common example here is that kind of transfer transactions, which is I'm consuming some coins, notes, outputs whatever in a transaction, and I'm generating new ones — could be sending them to myself, sending them to someone else, not of the business. We need to make sure that they don't create more value than they uniquely consume, meaning I shouldn't be able to consume a certain number of coins and then just generate a bunch more out of thin air unless the protocol wants that for some reason. And further I shouldn't be able to double spend funds, consume them in more than one transaction or within the same transaction and thereby effectively generate more funds in the system that are expected. And second, we do have certain kinds of transactions that are intended to add value. So value-adding transactions, a common example being a coinbase transaction which is specifically intended to add value into the system according to like an emission schedule, that needs to not create more value than what's expected. So there's different kind of ways to think about what it means to have inflation. If these are not met, then you have some form of inflation in the system. It means more value in the system is able to be spent than the protocol would expect. We don't want that. Click.

So some big questions we want to answer here. First, in what ways can inflation occur? The answer is there are many. It's not some nice little list of two ways that inflation could occur. It depends on the protocol, the implementation, the cryptography, all sorts of things. Second, how certain can we be that inflation has or has not occurred? Again it's going to depend. But we'll go through some examples. And third, what are the consequences if inflation does occur? I think that's a question that is talked about a bit less, but one that is suddenly very important, if inflation does occur in a digital asset that you care about. Once it's occurred you have to decide what to do and what can have big consequences. Click.

So first of all here are some common statements that I've heard that are subtly or somewhat wrong. One of which is inflation can't occur in a transparent asset like Bitcoin. That is wrong. We'll give an example. Inflation can and has occurred in transparent assets, Bitcoin is an example of this. Second, sometimes hear that while inflation can't occur if you just go through and look at every coinbase transaction, count up the transparent funds, because coinbase-transactions have transparent funds — that is the amounts in a coinbase-transaction have to be public, the network has to check that they are correct – well, what if we just go and count all of those up and we say: “Ah, that is the number that I expected”, well that is not sufficient to show that inflation has not occurred. Either there are other ways for inflation to occur besides coinbase-transaction incorrectly or maliciously including a bad amount. And another one is that inflation can't occur if you use transparent migrations. So ZCash is a common example of a fairly popular asset that uses transparent migrations, where you have a pool of shielded funds and at some point you upgrade to a new pool of shielded funds. And to move between those pools the protocol says you have to reveal the amounts as you're pulling them out of the old pool and into the new pool in an effort to mitigate inflation somehow. Well that's also not sufficient to mitigate all of the different effects and types of inflation, and we'll see why. Click.


So I have a little diagram here, it's okay if you can't fully see it, but it shows that in transparent assets the amounts that you consume in the transaction or spend and the amounts that you generate are typically in the clear. So we can see the amounts going in, we can see the amounts going out. And there's some kind of authorization in the middle that you have to use typically, like a digital signature of some kind, Schnorr signature, you know ECDSA whatever. And that authorization shows that you have the the ability, the authority to spend those funds typically with a private key. And what you can do in theory is you can go and just look at the inputs, you can look at the outputs, you can make sure they balance. On the left-hand side of my diagram we're consuming a coin worth two units and one worth five units, and on the other side we're generating outputs valued at two units, one unit, four units. If you go do the math with your TI calculator or just in your head hopefully, you can show that those balance. So no value was created in there, hooray! That's what a transaction very roughly looks like in certain kinds of transparent assets. Click.

But in private assets and the opposite of transparent is opaque. So I'll use the word opaque for this, because what a private asset means can vary from protocol to protocol. But we'll just say opaque assets are assets where the amounts that are consumed and generated are not in the clear. They are hidden. And there's typically the way that you do this is through a one-way algebraic construction called a commitment, where instead of showing the amount you basically secretly and in a hidden way commit to the value, but in a way that works really well with algebra and curve arithmetic and all that, such that ideally if everything goes correct you can prove that those inputs and outputs are supposed to balance. But the downside is you can't just do it by looking at the numbers and adding them up, because we don't just have the numbers, we have these kind of algebraic constructions. So instead of having values of two and five units going into my transaction I'll have some kind of algebraic commitment to the number two and a commitment to the number five. On the other side I'll have commitments to all of the output amounts, and we can't see those amounts, so we can't just add them up to make sure that they balance. But what you can do is you can do some commitment algebra and show that if I add and subtract them in a very specific way, I get some representation of zero. So it's like what does zero mean to you, it gets very philosophical in some sense. And you still have some kind of authorization in the middle that show that you have the authority to spend those funds. And in opaque assets like Monero or ZCash, or others, for example, these are kind of popular examples, those authorizations get kind of complex, like in ZCash there's different proving systems that are used in different balance checks, and signatures and things, and Monero uses ring signatures, and range proofs, and some other balance check stuff as well. But it doesn't get quite as simple. So you can't just go and add things up in typical transfer transactions, because you can't see the amounts. Click.

So what we need to do is to ensure that we don't have inflation, because that's the goal here, we don't want that. Now if you're dealing with an opaque asset type like Monero or others, we need to make sure that the value in the transactions is actually hidden. I don't want to somehow represent value in a way that just reveals it, because one of the points is that we don't want to see value, because ideally every transaction should be as indistinguishable as possible from every other transaction. What you do want — the rest of these things that I'm going to say are also true for transparent assets as well as opaque assets, and they're all kind of somewhat related, so these are not distinct things necessarily – one of which I want to make sure that unexpected value in general can't be created. That would be inflation. I want to make sure that the value in the system is always exactly what we expect it to be, again according to emission schedules, protocol rules, whatever. I want to make sure that value in transactions balances. We said that's pretty easy to do in transparent transactions — pull out your calculator — in opaque transactions you have these abstract commitments, that you have to contend with. I want to make sure that funds can't be spent multiple times. You know double spend, triple spend, whatever. One spend is all the spends you get. And I want to make sure that all of the authorizations are correct. Again we said that there's some kind of signature proof authorization that says you have the ability to spend these funds. Those are also a place where this can often go wrong in a way that can allow for things like double spends, and we'll see examples of this. So we need to make sure that those authorizations are also correct, and like we said, those can get very complex in opaque assets. Complex protocol, complex implementation — that means additional risks. So these all come with like different cryptographic and implementation risks that we'll talk about. Click.

So let's look at a few case studies of times when this has gone wrong. And then we'll look at a hypothetical case where it could go wrong in the future. So Monero is the first case study. So like many other opaque assets Monero uses something called a linking tag, you might also hear this referred to as a key image, a nullifier, a serial number, no one can agree on the words. They all roughly mean the same thing. They used as a so-called linking tag, I'll call it, to prevent double spend attempts. And the way this works is that every time that you consume a coin or spend a coin in a transaction, and again this is part of some set of possible spends dealing with ring signatures and such, but every time you consume a coin you reveal a key image, a linking tag. It doesn't identify the coin directly, but it is uniquely linked to that coin in a hidden way such that you cannot spend that coin ideally without having to reveal that specific tag. And the reason that's useful is every time that you as a network participant see a linking tag, you can see if you have ever seen that tag before. If you have seen that tag before, it is a double spend attempt, and you should reject the transaction. If it has not been seen before, you continue on with checking the authorization and doing other work for the transaction. The downside to this is that a bug existed in the Monero protocol and its implementation that would have allowed the owner of basically any coin to reveal multiple different linking tags for that same coin. You are not supposed to be able to do this. You are only supposed to be able to validly reveal a single linking tag for any particular coin that you are consuming in a transaction. And this was not just a double spend. This was like an octo-spend. You could have spent for algebraic reasons every coin eight times. That is very inflation, we don't want that. So what happened with it. Click.

Well the mitigation for this, which is written up here, is that the bug was privately just disclosed, it was actually  kind of secretly patched in a client update, with a basically an explanation that wasn't quite true in a client update, and then the details were revealed after the update. It's actually a very very simple fix if you go through and look at it. The effect of this though fortunately in this case the bug was definitively not exploited. We'll see examples of cases where inflation may not be able to be detected, but in this case it was able to be detected, and it was definitively shown that it was not exploited. And the reason for this was that these kind of like evil tags that you could have revealed separately for the same coin had a particular algebraic property that could have been checked, and no tags had this property. But like that would have been very, very bad had it been exploited. So that's an example of a case where a particular part of authorizations, the linking tags, had an implementation flaw that would have allowed for inflation had they been exploited. Click.

Let's look at another example of an opaque asset. A lot of people know about ZCash. So ZCash is proving system security. They use different kinds of proving systems and different versions of their iterations, of their protocol. They depend in part on these like multi-party generation ceremonies. You probably heard about it, like the ceremony, the trusted setup, whatever, the MPC. And these multi-party ceremonies generated the system parameters that were necessary to kind of bootstrap these iterations of the protocol, the Sprout, payment protocol had a ceremony, and the Sapling protocol had a ceremony as well. The next iteration of those will not have such a ceremony, because they're moving away from this kind of trusted setup. But these ceremonies came equipped with so-called transcripts, basically like files containing like parsable data that tools could use. And these would have allowed third parties to check the validity of certain parts of the ceremony, because part of the ceremony is you need to make sure that like all the participants in the ceremony did their steps correctly. And separately you also have to assume that they like got rid of certain secret data that they kept and if they would have all colluded this would break security. But there was a problem with the Sprout transcript ceremony. The Sprout transcript had a particular problem with it that would have allowed an observer, who looked at the transcript did some interesting math on it, would have been able to generate transactions, add them to the chain, that would have been able to add arbitrary hidden value into the Sprout pool. So had this been exploited, and I'll say in a moment that we don't actually know for sure if it was or not, it would have been possible to add arbitrary value into the pool by effectively fooling this form of the authorization, using stuff that was basically pulled out of this incorrect flawed transcript. Click.

So what are the effects? Well, mitigation: the problem was internally and privately disclosed and it was patched using kind of a combination of a proving system and protocol upgrade. That occurred so. The system is no longer vulnerable to new inflation that could occur this way. That was revealed after the upgrade happened. So all the details are made very public. There's a cool little short paper that talks about the math you would have needed to do in order to exploit this. It's very interesting. But the downside is in this case it is not possible to definitively know if the problem was exploited or not. And we'll talk a little bit more about how the idea of transparent pool upgrades and transparent pool migrations that ZCash does can somehow mitigate certain parts of this, but not in their entirety, which is kind of interesting. So another case study in this case the effect is that we don't know for sure if it was exploited or not. Click.

But now let's talk about what I'm going to call a “pretend case study”, because folks often bring up: “Ah, but what if you know we have some magical fancy quantum computer in the future”. What would that be able to do? Does that pose an inflation risk? So let's look at some kind of fancy adversary who has some kind of fancy quantum type computer that can break all sorts of interesting cryptographic hardness assumptions that we currently rely on for security. So pretend case study again, I don't know if this exists, I hope it doesn't exist, I have no reason to believe it does, but balance protection as we said in these so-called opaque assets use commitments, which is like this hidden representation of value, that doesn't reveal value directly. So Monero uses this, ZCash uses a form of it, others do too. And part of this balance protection depends in part on commitments not only hiding the value that you're spending, because we don't want to reveal it, but also that that commitment uniquely binds to a specific value. And what I mean by that is I don't want to be able to have a commitment that looks the same, representing two different values, that is very, very bad. So for example I don't want to be able to commit to a value of three units and have that look the same as a commitment that binds to a value of a thousand and three units, because in effect that means that I could claim that I have a thousand and three units in my transaction when in effect I only have three. You don't want this. So if I was able to like reveal an opening to this commitment to a different value than what was expected, that would fool the balance checks and basically give you I don't know the best, the worst kind of inflation ever, depends if you're the one who wants inflation or not. And it turns out if you have a fancy quantum type adversary that was able to learn a specific kind of algebraic relationship between some of the components that go into these commitments, these commitments are based on certain algebraic relationships, and if a quantum adversary were able to learn a relationship between these algebraic components, well, then they could do this, they could effectively represent any value they wanted to any hidden commitment. And that would allow them to fool the balance check and to cause inflation. So the question is how likely is this? That's a great question. Some people think that this is the thing that is imminently possible tomorrow or yesterday, and others who say: “No, no. This is an extremely complicated problem that may never see fruition in any of our lifetimes or many lifetimes to come”. So I don't have a particular opinion on this, I'm not knowledgeable enough in this space to be able to say if this is likely or not, but I can say that like I would say overall it's considered exceptionally unlikely, that this would be feasible I would say in the near future. But again that depends on who you ask. And certainly not without some kind of fancy quantum adversary. So in theory you could try to brute force this particular algebraic relationship, but this is like length of an uncountable number of universes, length of time in order to do it. So I don't know, I'm not personally losing any sleep over this, but I'm sure that people are so. Click.

So what would be the mitigation to this? Well there are some options: I could use some different types of cryptographic components in plumbing in an attempt to try to mitigate this or allow for an option to mitigate it in the future. But there's other cryptographic and efficiency consequences to this that I won't get into here, because they're a little bit technical. The effect would be though that it would not be possible to definitively know if this problem were exploited. If someone sitting in some I don't know very large expensive basement with a very large expensive quantum computer is able to do this, we wouldn't be able to tell now anyway, so this would be an example of undetectable inflation. Click.

All right, so let's go through some things that, you know, some folks suggest that we do, we talked a little bit about them before, but we said earlier well why can't we just count the coinbase funds that we throw into these opaque pools, either through you know migrating transparent funds, if your protocol allows this, into a hidden pool, or through things like coinbase transactions that are intended to add known visible value into some kind of hidden pool. Well, it is true that higher than expected coinbase value addition is one way for inflation to occur. I mean I don't know, maybe your code doesn't check the amounts that coinbase transactions list. That would be a very foolish thing to do. But if your code didn't check that, and you were able to add arbitrary amounts of value in through coinbase transactions, well then that would be inflation. You would be able to hopefully detect this, because someone would ideally look and say: “Well, that doesn't look quite right”. But that again is not the only avenue for inflation to occur. We've seen other examples where inflation could occur that have nothing to do with coinbase transactions or counting values. So it is important that you check this and that your code check this but it is not sufficient to mitigate all forms of possible inflation. Like we had said this wouldn't detect any problems with authorizations, like happening ZCash, this wouldn't detect things like fancy adversary quantum cryptographic breaks, that we talked about, and it wouldn't be able to detect other kinds of consensus rule problems. And we'll give some examples with Bitcoin that went wrong, where Bitcoin is not an opaque asset. Click.

Well why can't we just use transparent migrations to ensure that, you know, if I require that moving from a hidden pool to a hidden pool, if that requires a transparent value revelation as I'm moving between those pools, well why can't I just look at that amount and ensure that too much value doesn't come out. Well in effect this is just kind of moving to a different kind of coinbase transaction, right. A coinbase transaction says you know here is some value, I'm adding it to the pool, is this the correct amount of value to add to the pool. For a transparent migration you're pulling hidden value out, so it's not exactly like a coinbase, but then you're like basically saying how much value you're putting into the new pool. It shares some similarities, I would say mathematically and kind of philosophically, with a coinbase transaction. So ZCash for example used a transparent migration when they introduced their new Sapling protocols pool. And you could move funds between the Sprout pool to that Sapling pool, you could move it out into transparent land, or you could try to move it into new Sapling land, which gives you more efficient operations. But again to go from Sprout to Sapling you had to reveal the amounts. So well they said, we're going to institute a rule that says: if more funds leave the Sprout pool then were originally transparently put in, so if the pool were to so-called go negative, the consensus rule that they put in place was that any remaining funds in there would be frozen. You couldn't pull them out of the pool anymore, everybody in the pool stays in the pool. Well other protocols could of course decide to take different actions in response to what would happen here, but they set this particular rule in place. Click.

So what would be the consequences of this, because this is a really interesting problem. So a few consequences. One is that if an attacker did decide to pull out enough funds, so they have in this example somehow found a way to exploit this transcript flaw or some other avenue of inflation, and they've inflated the Sprout pool but in a hidden, way well if they were to pull out enough funds to make the pool negative, any remaining honest users funds would basically be subject to whatever consequences your protocol decides. In the case of ZCash no more Sprout value may exit the Sprout pool. Well what if the attacker instead decides: “Well I don't want to do that, because that's going to cause the whole world to go into chaos, and I don't know maybe the price drops in my money that I inflate it isn't worth anything anymore”, well the attacker could still decide to pull out some inflated funds, but they might be very careful to do it in a way that doesn't force that pool to go negative. Would anyone be able to tell probably not the point of a hidden pool is that you couldn't tell how much how many funds the attacker had access to in the first place. And of course the attacker could still spend their inflated funds within that pool. The trick with this is that transparent migrations only work if the funds leave the pool, but if you're still spending funds within that shielded pool and never leaving it, well any inflation that could occur, any funds that were there would not be subject to this transparent migration at all, and inflated funds could still be spent within that pool. And finally, just kind of as a separate issue, these so-called migration transactions reveal amounts. And we know that transactions in Monero and ZCash, and others are not just some beautiful uniform blob of nothingness, they have metadata attached to them you know, they also have like network type data attached to them, your ISP can see what's going on in your network if you you know don't use some method to mitigate that, and like we said amounts are being revealed, and that could introduce risk as well. So this is a very, very fascinating problem. And this can mitigate some forms of inflation type risk, for example, if the pool goes negative that would in theory affect the known supply. But you have to decide what you're going to do about that. Click.

So what about transparent assets? We said before, an incorrect statement is that there is no inflation in transparent assets, that is not the case. Transparent assets can have and have had inflation bugs some of which have been exploited. So click.

So let's look at... back. Click.

So let's look at an example with Bitcoin. I know about two different potential inflation bugs in Bitcoin and let's talk about one that was actually exploited, and you can look up the other one if you like. So as you probably know the Bitcoin protocol does contain consensus rules implemented in code that require that the amounts consumed and generated in a transaction must balance. So you can't throw up more transparent value than you put in. That's consensus and code rule. But a bug existed several years back that would have allowed the coins to be generated, that had such huge amounts associated to them, that when they did all these additions and subtractions to make sure that the transaction balanced, there was an overflow. And if you know anything about how like the math behind that works, you know this is very, very bad, because it turns out that when you sum all of those amounts, if one of them was so large that would have triggered this overflow, the balance equation actually looks correct, and the code would have passed this transaction despite the fact that it is very obviously generating way more value than it was supposed to be generating. So the balance check was fooled. Fortunately this was noticed by people who saw these amounts and thought: “Huh, this doesn't make even a lick of sense”, and the code was patched within I think it was like five hours or something. It was incredibly, it was obviously incredibly fast, because this was exploited and a transaction did exhibit this behavior. Click.

So the mitigation... yes, so an exploit was observed in a transaction and it was patched in a client update. And the effect of this was that well the bug was definitively exploited, because people looked at it, and saw it, and patched it very, very quickly. But it turned out that because of that the chain was effectively softfork to undo that transaction. And fortunately in that case it turned out those funds had not been spent anywhere else. Had they been spent anywhere else, now you have to decide what you're going to do to potentially honest users transactions. I mean if someone, you know, if you're a retailer, someone were to exploit this, and then spend funds to you, which you then want to use, what happens if the chain forks? You no longer have those funds, but you've already sold whatever product you were selling. Those are difficult decisions. Fortunately in this case the decision was quite straightforward I would argue. So the mitigation on it was pretty effective, and I would say the effects were minimal. But this is an example of a case where you do have to make some tricky decisions when inflation can occur, and does occur. Click.

So what are the lessons from this. I would say that there are a lot of lessons from this, and like I said it's a very subtle issue. So here are some things that we can learn from and there are many other examples, like there are so many case study examples that we just didn't have time to talk about. And I recommend you look some up because they're very fascinating. First of all is that not all forms of inflation and not all inflation risks are the same. We've seen several examples that differed in many different ways. So they can arise from things like cryptographic breaks, different hardness assumptions, they can arrive from consensus rules that are either designed or implemented poorly in code, they can arise just from implementation flaws of good protocols that just have bugs in them, code has bugs, and these are often very complex pieces of code, or they can involve bad protocols that aren't designed correctly to avoid all sorts of attacks that you want to avoid. The second is that in opaque assets inflation may be detectable but not always. We saw in the case of the fancy quantum adversary you know such an attack would not be detectable. In the case of Monero the particular flaw that we saw was detectable, in the case of ZCash the bug that they had would not have necessarily been detectable, depending on how the attacker might act. Just to be clear that pool hasn't gone negative, so we know that it we can't say that it has definitively been exploited, but we can't say that it definitively has not. The third lesson I would say is that you can still have inflation in transparent assets. And while it is in theory detectable it does have consequences. So you have to detect it either you know looking to see which funds may be double spent or what amounts seem like they might be off and don't properly balance, so you may be able to detect that but it does have consequences. What do you do if inflation occurred? Do you roll back a chain and just hope that you know no one else is affected? Well I don't know. That worked for Bitcoin a few years back, if it were to happen again the effects might be a lot worse I'd say. The fourth thing is that things techniques like you know transparent migrations or you know counting coinbase funds, those things you know can be useful to mitigate certain kinds of risks, but I would say that they're definitively not sufficient to mitigate all possible risks and effects of inflation in opaque assets. We have examples of these things and you could probably think through a lot of other use cases or circumstances in your mind too. Click.

So I think we're pretty good on time. Are we? Okay, cool. So yeah, are there any questions? I think uh Justin's gonna bring a mic so that everyone on the live stream can hear you too. All right.
_**Audience:**_ I have a question about the potential of a quantum adversary doing the exploit that you did... in the case of if it was possibly detectable, would it be, would there be a trace of whether it be classical or quantum adversary of what type of method was used?

_**Sarang:**_ You need the example of finding a discrete log relationship between those commitment generators?

_**Audience:**_ It could be that...

_**Sarang:**_ The one that I referenced? I mean, no... That would not... I mean I'm sure you could design a transaction that is traceable, because you're not doing a good job of being an attacker, but no like I don't see it, I don't see why I would have to be detectable at all.

_**Moderator:**_ Well that's I guess that's not really the question I'm asking, is the question sort of like if in the exploit that you were talking about, in which someone might have been able to like... not that.... never mind... I mean it's just like how can you trace if it was traceable? How could you trace what method that someone used I guess?

_**Sarang:**_ In that particular case I don't see that you would be able to. And then effectively that's the risk.

_**Audience:**_ So like if someone did something like that you couldn't tell whether it was a classical, so what type of fancy computer someone's using is. That's what I was asking

_**Sarang:**_ Oh, no, no, no. This would just be, you know, I mean again in this particular example it's just can you find a particular discrete log relationship between these generators. And again like you could try to brute force them too. You're never gonna fingers crossed in like many universe ages, because like the the size of these groups are absolutely enormous.

_**Audience:**_ You just need to pray RNGesus.

_**Sarang:**_ No, I mean, I don't know like go pick some random group elements maybe you get lucky and you find the discrete log relationship. And again, I should also say too, that there's also the argument that a quantum computer that could break this particular cryptographic hardness assumption, you know, could also do a lot of other things besides inflating funds. Like you know finding out secret keys and just spending other people's funds, and breaking the entirety of the Internet. So it's if the world's on fire, you know, your house is probably on fire too. But many other people have problems too

_**Audience:**_ All right, great. Awesome talk, thank you. I felt like I was like in an inside room with all you guys learning about what you're working on every day, but my question is, I understood where you're coming from, and a lot of projects can work on inflation, but at the end of the day we're connected to fiat and we have a price via to crypto, balance or percentage. How can we completely detach from fiat, because even if we work on our inflation, USD is inflating daily, so it's gonna cascade down into Monero. So maybe it's not your forte, or what you think about every day, but how do you imagine that we can just detach from the fiat connection besides the obvious answer of adoption?

_**Sarang:**_ I am not the person to ask about that. I'm a math guy. And that seems like I don't know a social and economics problem. I don't want to pretend to be an expert in those things

_**Audience:**_ All right, I got you.

_**Sarang:**_ Yeah, I can talk about protocol-related inflation. I'm not the one to ask about about USD inflation

_**Audience:**_ Ok, I'll pass a mic.

_**Moderator:**_ Thanks. Are there any other questions? Oh, there's, great.

_**Audience:**_ So I've seen a nation state like the US or some other government wanted to take down Monero or do something bad to it. How many developer computers would they need to get into to alter the code, or how much, how feasible would that be to alter it?

_**Sarang:**_ Oh, I also don't have a good sense of that. That's very much kind of like an operational security problem. But yeah that is also a very good point, because we did say that a lot of these things, and a lot of these risks can arise from code and implementation flaws you know. I mean for example like Monero was patched to remove this flaw, but you know what if someone instead had, you know, done a patch that introduced it, which, you know, in theory someone could do this, if they were able to get past code review and things like that. I mean I don't have a good sense for how hard that is, because I think it really depends on like what the protocols are for code review. I think that having kind of a reduced trust environment seems to be one good mitigation against this by assuming that all code might be malicious when it's introduced. But you know it's tough right. There's a lot of code, and there's probably a lot of different ways to introduce flaws that might be very difficult to detect even if you're very good at code review. So yeah I think it's just a sign of constant vigilance in free and open source projects.

_**Audience:**_ Do you know how many computers more or less that would be?

_**Sarang:**_ I guess I don't understand quite what you mean by the number of computers. Are you talking about trying to introduce malicious code into the code base?

_**Audience:**_ Yes, how many have access?

_**Sarang:**_ You mean like to do merges? I'm actually not sure the number that are allowed to do merges. I mean the nice thing at least is that you know all merges are at least visible, you know. You can see merges, you can see what's going on, you know, where a merger to take some action that the community thought was inappropriate, I suppose it could be efforts to fork or something like that. But I don't know, I don't have a good sense for, you know, how many people would you have to infiltrate to be able to make a difference in that. But that's a good point though. Like it's something definitely to watch out for, because you know a protocol can be great, but if its implementation is poor or maliciously influenced that's bad.

_**Moderator:**_ Great, great questions, men. Great questions. And our next speaker might have some insight into that as well. Any more questions? I'm sure you guys actually do have more, but...

_**Sarang:**_ I'll be around if anyone wants to chat about this later too. So thanks for your time

_**Moderator:**_ Yeah, all right.

_[Applause]_

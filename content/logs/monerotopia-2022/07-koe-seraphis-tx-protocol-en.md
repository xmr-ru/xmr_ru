---
title: koe - Seraphis Tx Protocol
date: "2022-05-11"
categories:
  - ""
tags:
  - ""
lead: "Koe, a Monero contributor and the lead developer on the Seraphis project and primary author of Zero to Monero, speaks about Seraphis Transaction Protocol, at the Monerotopia 2022 #XMR4ALL event!"
pager: true
toc: false
sidebar: "right"
---

{{< youtube id="XbMLK-aarKU" autoplay="false" >}}

---

_**Moderator:**_ We have koe coming up, allright. So also another megabrain in in crypto in general. And we're fortunate enough to have him on team Monero, he's a dev for Monero. He will be talking about implementing Seraphis, so like we were talking about earlier ring signatures in the need to improve upon them, and improve the ring size — all this ties into that. He's gonna, I don't know to what level of technicality he's gonna get into, hopefully you can hang on. But he not only is, he you know the guy that that you know building this stuff, but he does have an amazing ability to distill and explain the information. So definitely take advantage and have a have a strong Q&A with our next speaker as well. I'll leave it at that. koe take it away.


_**koe:**_ Thank you.

_[Applause]_

All right. I'm gonna talk about Seraphis today. Next slide. Part one. I'm going to explain what a transaction protocol actually is. Next slide. So this is… oh my god, you can't read that. This is the general outline of what's in a transaction. So a transaction is something that you add to the ledger in order to move funds from yourself to other people.

So I say that Bitcoin and everything else after that including Monero is in the so-called ‘enote’ paradigm, you know, is what I call an output or a transaction output. So an enote is just a little message that says: ‘this person owns this amount of money’. That's all it says. The important thing about an enote is that it encapsulates ownership. So the owner of this enote is the person who has the exclusive power to assign a new owner of the funds with the enote.

So transaction events are simply the spending of owned enotes by some person and the creating of new enotes for new people to own the funds. So the inputs to a transaction are old enotes that exist in the ledger that you want to move the funds out of and so… To spend an enote there are three things necessary: you must prove that the enote actually does exist in the ledger, you must prove that you own the enote, you have the right to spend it, you also have to prove that it hasn't been spent before. All right. So the outputs of the transaction are the new enotes with new owners, and all you have to do is prove that the amounts balance between inputs and outputs. Go on.

So what Monero adds to this simple enote based transaction paradigm is the ‘need-to-know design’. So the focus on privacy in Monero. So with recipients the only information a recipient of an enote needs to know is how much money they received and when they received it. They don't need to know, they don't need to be able to look in the ledger and see who sent them that amount. This is similar to cash — so if you have a piece of cash you don't know who you got it from, it's just this piece of money that you own. So the senders of a transaction they know who they sent money to like implicitly and they also know the amount of money they've spent and when they spent it. So they can look on in a ledger and see that they've spent their money, and they know when they spent it. But they don't know if or when the money they sent someone is spent after that. Observers of the ledger know if they can look, we expect that if they look at the ledger and see a transaction, then they will know how many inputs and outputs it has, the fees of the transaction, and when approximately when the transaction was constructed. But they don't know anything about the amounts other than the fee and the relationships between different transactions in the ledger or the amounts owned by any specific user. So this is a separate idea from the amounts in a transaction is the amount owned by any user. Next slide.

So this is you could say the current state of privacy focused transaction protocols. So everything in the green is what we achieve right now with the technology available to us. So basically this is what we get with RingCT and everything that's similar to RingCT. We hide the amounts, we hide who owns money, we kind of hide when a transaction is like. So this yellow one is when transaction constructed. We want to hide that information, but it's like technically impossible to do that, because of transaction fees which are contextual to the when you construct the transaction. But you're right here in red it says relationships between transaction events. So observers can look at the ledger and infer some information about the relationships between different transactions. And that is, next slide, because of membership proofs.

We want to prove that our enote exists on the ledger when we're spending it, but we don't want to tell anybody which one it is. The solution that's been adopted with since CryptoNote with Ring Signatures is this idea of a partial anonymity set. So we say, we take some small group of enotes that are in the ledger and we say: ‘We're going to spend one of the enotes that's in this small group’. So we have this partial anonymity set. We don't say which one in the small group we're spending, but we do prove that we are spending one in that group. And since that group is from the ledger, therefore the enote we're spending is in the ledger. But this is incomplete. What we want is a complete anonymity set where we say we're referencing the entire ledger when we say: ‘We're spending something’. So the only solution that is currently in production is the ZCash-style oblivious Merkle proofs which I personally don't know anything about, but they're very opaque and very expensive, which is one of the reasons Monero does not use them. In the future perhaps a better solution will present itself, but that's in the future. So, next slide.

Historically, so these are historical protocols that have been of interest to the Monero community, of course CryptoNote and RingCT are protocols that have been implemented and used, the important thing about all of these protocols is that they combine all of the input proof statements into one proof. So this one structure that proves all of these ideas, a combining into one like structure. And the cost of combining these proofs is complexity. So these proofs have to be very complex in order to satisfy all the requirements. And also there's an efficiency cost, because like a kind of a multiplicative effect of trying to do one thing and then another thing and so you end up multiplying the cost of these together instead of adding them together. Next slide.

So now we can go into Seraphis which is attempts to address some of those drawbacks. So this the transaction structure of a Seraphis. The first part up here is transaction inputs. Transaction inputs have three pieces: we have an enote image, which is a representation of an enote that we're spending, we have a membership proof, which is a distinct structure, so in other protocols the proofs were together, but now we're separating proofs from each other, so in Seraphis we have a distinct membership proof that shows that the enote corresponds to the enote image, corresponds to an enote in the ledger. And so you can do this with ring signatures just like we have with RingCT, but the structure itself is simpler because we're only doing membership proof. We're not doing anything else with this proof. We're just showing membership. So separate from the membership proof is the ownership proof, which is showing that whoever is making this transaction, authorizes the spend of the enote, of the transaction input. Associated with this is the key image proof which proves that you know enote you're spending hasn't been spent before, which I mentioned in the beginning.

The next part is the transaction outputs. As usual we have enotes which are new amount owner messages, and the range proof as usual which helps make sure, like Sarang was talking about with amount overflows, it prevents amount overflows which can lead to inflation. This is what we have with RingCT as well. And so as usual we also have a balance proof which shows that input amounts sum to output amounts, and miscellaneous pieces, so transaction fee and memos. So this is everything that's inside a Seraphis transaction. We have the transaction inputs with the images of the enotes being spent, membership proof and ownership proof we have transaction outputs with new owner amount messages, and range proofs, balance proof and miscellaneous memos. Next slide, okay.

So the one additional advantage of separating the proofs within Seraphis is you can do a lot of what I call transaction engineering. So in the current Monero protocol with RingCT you kind of have to build the entire transaction in one go and then submit it. So you can't build a piece of it and then later make another piece, and then combine them, and then submit it. So but with Seraphis we can do this, so there are a few things we can do. One is you can make an isolated enote. So you can write the amount owner message without at the same time doing anything else with the transaction. So one thing that's kind of… so with RingCT everything is tightly coupled together all the pieces are coupled together. If you want to specify the outlays of a transaction, all the outputs of the transaction, you have to do it all together at the same time. But with these isolated enotes you can make them separately in isolation, and then at a later time make a transaction that sends funds to that enote, or you could take that enote and build a transaction on top of it without that enote even needing to be in the ledger. That's transaction chaining, which I'll get to.

So another thing you can do is ‘delayed membership proofs’. So you can specify the outputs of the transaction and prove ownership of those and also specify the inputs and prove that the inputs fund the outputs, so they prove that you own them without proving that the enotes that you're spending are in the ledger. So this means you can build a transaction that spends enotes that aren't in the ledger yet. And then oh that's transaction chaining again. So basically you build most of the transaction without building the membership proofs, and then at some later date right before you want to submit the transaction you can build the membership proof which lets you delegate the building of the membership proof to a third party, although that has a lot of privacy implications, but in the case of multisig you can… it greatly simplifies the amount of communication required and reduces timing analysis of when a transaction is constructed, because with multisig you often build a transaction a long time before you actually submit it. So if membership proof was built at the same time as when you start building the transaction, then the age of the references in the membership proof would reveal when the transaction was constructed. So with delaying the membership proof until the very end you can kind of remove some of that timing information, although transaction fees are very contextual, so this is kind of reveals some timing information anyway. It also lets you have simpler hardware wallet implementations. Right now a hardware wallet implementation has to construct an entire transaction, but if the membership proof can be delegated to like your phone, completely delegated, then the hardware wallet doesn't have to know anything about membership proofs, not what implementation is used, nothing. Hopefully makes it simpler. I don't actually know a lot about hardware wallets but I'm hoping this makes it easier to implement.

So transaction chaining is the really exciting piece here. So the idea that you can chain transactions together with none of them being relating to enotes that are in the ledger yet. Apparently this is exciting for atomic swaps which are currently… the atomic swaps protocols are incomplete, because of the lack of ability to do this kind of transaction chaining stuff. So I think it'd be more featureful with this ability to do transaction chaining. And there are probably a lot of other applications of this transaction chaining technique that I can't even imagine. So hopefully those ideas will crop up in the future.

So the final thing is partial funding of a transaction. So right now only one person can fund a transaction, one person builds a transaction and submits it. But with this partial funding idea you can get many people to contribute inputs to a transaction and that's pretty straightforward I think. Next slide.

Here's some performance graphs, they're kind of hard to see. I did a bunch of comparative performance between different protocols. So we have here CLSAG, which is what this line here is CLSAG. This is verification time versus how many members are in the ring signature. Up here we have CLSAG which is what we have in the current protocol. So right here is 11 ring members, right here, over here is 128, up here. We also have Triptych and then some variations on Seraphis, how to implement it. These are all kind of similar, but what we see here is that at 128 ring size we have a similar verification cost as around 16 ring members in a CLSAG. Over here we have transaction size versus reference set size, CLSAG again in this graph here. And then Triptych is a little bigger than Seraphis due to… so Triptych is one of those protocols that combines proofs together. So here you can see a direct effect of decoupling the proofs as you get smaller transactions, because you don't have to worry you don't have to like that multiplicative effect of doing everything in the same place. So let's see 11 here, so it is at ring size 11 we have smaller transactions with CLSAG but with the next hardfork we're going to 16, so up here we see already that at 16 ring members we have a similar performance or similar transaction size to Seraphis. At 128 it does get bigger though than the 16, but not significantly, all right. Next slide.

Here's more performance stuff. So one nice thing about Seraphis is you can do a lot of transactions with the proofs that are the proof like the specific proofs that are available. I call them Godel proofs. You can do a lot of batching so and also with the range proof. So batching means if you have multiple transactions and you want to verify them together then it's faster than if you just verified them individually. So here we have verifying 25 transactions together, 128 ring size with the fastest Seraphis implementation is faster than CLSAG with 16 ring members. And here's a batch size versus verification cost for 16 inputs and 16 outputs. So this is just comparing two of the Seraphis implementations. So as the batch size increases this implementation is significantly better than the other implementation due to a more batching that you're able to do with this technique anyway. You can get going, next slide.

Jamtis. So this is an addressing scheme for Seraphis. So an addressing scheme is how you implement ownership of an enote. So it's kind of opaque to say you own an enote and then you prove that you own it. But to do that we use cryptography and the cryptography there are many different ways to do the same thing kind of to prove ownership and to have ownership. So Jamtis is a scheme that works well with Seraphis from the user's point of view. So there's a new we have new mnemonics, however you say that word, with this polyseed technique developed by tevador. So that polyseed, menmon… oh god damn it, there's 16 words and it embeds the restore height. So it's a little smaller and more useful than the current word set. We're also planning to deprecate the normal and sub-address and integrated address distinctions, and have one unified address type which would hopefully improve the user experience. So here's an example of an address. As you can see it's quite long similar to how the current addresses are quite long and unreadable. So tevador came up with this recipient IDs which are like these little strings here, that are a lot easier to read and let you manually validate that like this big address corresponds to what you expect it to be. And there's no like typos or something stuck something in there shouldn't be in there. So I think that'll be helpful. Next slide.

So the big thing with Jamtis that's really exciting is the ability to have these very distinct wallet tiers that are very different from what we have today. So at the top is the usual wallet which is the master wallet that can do everything. So it can view the full balance, everything that you own, and it can be used to make new transactions and spend funds. So with this you'd have a like a normal wallet or a hardware wallet as a master wallet, can do everything.

And then the really exciting one is this ‘view all’ wallet. This is the wallet that can view the full balance of your wallet without being able to spend. So the view wallets we have today can only see the enotes that you receive. They can only see incoming funds. They cannot see when you spend funds. So they can actually be used to know what your balance is, your current balance. There are some heuristics that you could use but they're very impractical. So we get the ‘view all’ wallet which should hopefully make a lot easier to use hardware wallets, because now you don't have to do this so-called key image exporting process to learn what when you've spent something. So the view only wallet just always knows your full balance. And then when you want to spend something you could interface with your hardware wallet to sign something but otherwise other than when you're signing something the signing device it doesn't do anything.

We also get the ‘view received’ tier which lets you view incoming enotes, like what we have now with the view only wallet, and this can be useful for payment validation like with merchants.

We also get the ‘view find received’ tier which is complementary to the view only wallet. So right now if you want third party scanning, if you want someone to do all the work of looking for the stuff you own, you have to give them your view key, you have to tell them, you have to allow them to learn all the amounts in every in the enotes that you receive. But with the ‘find received’ tier this is a pre-processing tier that pre-processes enotes that are found in the ledger. But it only reduces the ledger so the all the enotes in the ledger it only reduces them by a factor of 256. It filters out a lot of enotes but it doesn't read the amounts in the enotes, and it doesn't know necessarily know which enotes actually correspond to you. This tier it just finds enotes that might be yours. So this tier could be used for a third-party scanning service that pre-processes enotes and then sends them to a view only wallet which finishes processing them in a very short amount of time. So the thing with this tier is pre-processed enotes can be analyzed very, very fast, because all the pre-processing does all the heavy lifting. So when it lands on your view only device it can finish the processing very quickly. Right now when you have with the if you want to like use a remote node to scan the ledger, you have to wait a long time for all of the enotes to be fully processed. But with this workflow the third party would do a lot of filtering and pre-processing without learning too much information about what the money that you own, and then you do the rest of the work on your local device, and yeah should be a big improvement hopefully.

Also the final tier is this ‘generate address’ tier. So with Jamtis we have this encrypted address index that's attached to so we add that into the enote. So it's a little memo field that's added into transactions and lets you when you receive the enote you decrypt this message, this memo, to figure out which index, which address index owns the enote. So this is like which subaddress owns your enotes. You have a bunch of different subaddresses, under each subaddress are the list of the funds that that subaddress has received. So with this you can generate a random index. So currently to find funds to all your subaddresses you have to pre-compute all the subaddresses that might have funds and then look and then when you're scanning you do a look up against the ones that you've pre-computed. So there's only like a finite or small set of possibilities when you're scanning, but with this this encrypted address index technique you don't have to pre-compute anything. When you're doing the scanning you figure out which address owns it in place. So this lets you generate addresses with random indexes which could be very helpful for merchant points of sale that which doesn't need to know what other addresses which have been generated prior. So the goal with this is to deprecate integrated addresses which are addresses that contain a payment ID. And so if you remove the payment ID how does a merchant distinguish between purchase orders? So you make a purchase and then you send funds to the merchant, how does the merchant know which product corresponds to those funds that you paid for? So with these random indices hopefully the point of sale can associate a random index with a purchase order and that'll make it easy for the merchant to keep track of things. All right, next slide.

That's the end. Any questions?

_**Audience:**_ I was just wondering if there was a timeline for these things?

_**koe:**_ So I've been working on an implementation… I think you go back a few slides, it's on one of those slides, okay you can't read it anyways, so it doesn't matter. I've been working on input implementation, I've had a couple of CCS proposals that are funded, I made the proof of concept of the core library, and now I'm working on a proof of concept of the wallet. But in terms of timeline for it to be like a hardfork that implements this, probably not until 2024 or later, who knows how long it'll actually take to fully get this working. That's the goal.

_**Moderator:**_ Anybody else? Our next speaker.

_**Audience:**_ I had a question. You're talking about Merkel proofs and how they're kind of annoying. Have you thought about using vertical proofs or I mean you know that is where they use polynomial commitments instead?

_**koe:**_ As far as I know those are not hidden. Okay, yeah I did look at them, but yeah so one thing one interesting thing with those is the I think the efficient implementation they use is requires a trusted setup, which was kind of hidden inside the info, inside the details. It was not fun to find that.

_**Audience:**_ I don't know if you covered this, because unfortunately I wasn't able to listen to most of the talk, but I will go back and listen to it 100%. This idea of Monero potentially being used as a communication network as well sometimes tossed around you know, so in addition to sending transactions sending a message with it, which is essentially what you're talking about. But do you ever see that being used for the purposes of you know communicating messages in addition to transacting?

_**koe:**_ I think it's better to like my opinion is it's better to focus on doing one thing well instead of more than one thing. So what we do, what we're trying to do is private cryptocurrency. Everything we do is focused on that. And so I mean we have this so-called the tx extra which is just this arbitrary memo field. So you could put messages in there, but maybe you should use like a something that's actually designed to be a messaging protocol for that, I don't know. We're not putting our effort into designing a messaging protocol.

_**Audience:**_ No, no. I know, I know that's a standard answer. I just wanted to hear you say what's the reasoning for that, and I think I know the answer to that as well. But if you guys

_**koe:**_ We have finite mental resources and the blockchain itself is finite.

_**Audience:**_ And then also I guess it opens up to essential attacks, right, this ability to gain more information about transactions potentially making them less fungible.

_**koe:**_ That's true as well. So every time you make a transaction that's distinguishable from other transactions because of some heuristic, like my transaction uses the messaging protocol, but most of them don't. Then you've opened yourself up for a more fine-grained analysis of your transaction history which… every little piece of information adds up into possibly of a significant deanonymization attack.

_**Audience:**_ So do you see a tool like that potentially being something that would then be on like another layer or just how do you where do you see that coming into the evolution of Monero?

_**koe:**_ Like a messaging protocol? I don't know. It's just a messaging protocol right?

_**Audience:**_ Yeah so just unrelated digital cash messaging protocols?

_**koe:**_ Quite different things.

_**Audience:**_ Yeah, yeah, for sure.

_**Moderator:**_ Anybody else? Have any questions? Let's go over here first.

_**Audience:**_ So there's been some discussion about potentially moving away from ring signatures and to like a zero knowledge type proof. You know a long way off but on the horizon. I guess it's kind of the transactions have been modularized a bit more. Does this help with that going forward like if you did? Will it make things easier to move that way?

_**koe:**_ That's my hope, that's like one of the original ideas that got me into this or got me thinking about this new protocol was separating things, maybe that'll make it easier for a better membership proof. But I don't know if that'll ever come to fruition or not.

_**Audience:**_ Okay, great.

_**Audience:**_ So my question was to focus on your group membership in hardware wallets. Is the hardware wallets still going to have a verifiable way of knowing who it's going to in the amount. But all it has to do is just do the final signature is it posted now where it has to do an ungodly amount of construction techniques. Is that the hope of your group membership idea or that's all the question, or was that too?

_**koe:**_ It really depends on how much you implement in the hardware wallet. So the hardware wallet just needs to sign something. So it has this key and then you say here: ‘Please sign this message for me’.

_**Audience:**_ Well okay. We'll have to talk because most of the hardware wallets currently on Bitcoin display the amount and who it's going to as a security feature. So that's why I was…

_**koe:**_ It depends on how much is implemented within the wallet.

_**Audience:**_ Okay

_**koe:**_ So I think.

_**Audience:**_ We'll have a long discussion about this but I like the wallet construction stuff is very complicated for hardware wallets for those that don't know. So there's any improvement on all that it's a huge game for Monero.

_**koe:**_ Hopefully someone who knows about that can take a look and actually tell me, because I don't know anything about it.

_**Moderator:**_ Oh man we're falling behind, but this is we needed two days for this conference, we definitely needed two days for this conference. We're showing so much good stuff in there. I do have one final question or then ten minute lock time, is it?

_**koe:**_ No, just give up.
